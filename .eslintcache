[{"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/index.js":"1","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/App.js":"2","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Controller.js":"3","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Model.js":"4","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/View.js":"5","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/ReferenceTools.js":"6","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Set.js":"7","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Light.js":"8","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Shapes.js":"9","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Parameters.js":"10","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/VisualisationMenu.js":"11","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/GeneralMenu.js":"12","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/Tools.js":"13","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/SubMenus.js":"14"},{"size":198,"mtime":1678842328969,"results":"15","hashOfConfig":"16"},{"size":928,"mtime":1678842325998,"results":"17","hashOfConfig":"16"},{"size":13145,"mtime":1681748818100,"results":"18","hashOfConfig":"16"},{"size":22985,"mtime":1681746270290,"results":"19","hashOfConfig":"16"},{"size":6664,"mtime":1681569826636,"results":"20","hashOfConfig":"16"},{"size":3901,"mtime":1681579447502,"results":"21","hashOfConfig":"16"},{"size":17393,"mtime":1681751099594,"results":"22","hashOfConfig":"16"},{"size":1375,"mtime":1678842326000,"results":"23","hashOfConfig":"16"},{"size":24017,"mtime":1678842326001,"results":"24","hashOfConfig":"16"},{"size":654,"mtime":1678842326001,"results":"25","hashOfConfig":"16"},{"size":6810,"mtime":1681516179197,"results":"26","hashOfConfig":"16"},{"size":14185,"mtime":1681656405566,"results":"27","hashOfConfig":"16"},{"size":6734,"mtime":1681222577578,"results":"28","hashOfConfig":"16"},{"size":37841,"mtime":1681601850453,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"trfy6y",{"filePath":"33","messages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39"},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"46","messages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"32"},"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/index.js",[],["61","62"],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/App.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Controller.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Model.js",["63","64","65","66","67","68"],"import {\n    Scene,\n    WebGLRenderer,\n    PerspectiveCamera,\n    OrthographicCamera,\n    Vector3,\n    PlaneHelper,\n    Plane,\n    MeshLambertMaterial,\n    Mesh,\n    Quaternion,\n    MeshBasicMaterial,\n    InstancedMesh,\n    BoxGeometry,\n    Euler,\n    Matrix4,\n    Color\n  \n} from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport Set from './Set.js'\nimport Light from './Light.js'\nimport ReferenceTools from './ReferenceTools.js'\nimport { Alert } from 'rsuite'\nimport * as SHAPE from './Shapes.js';\nimport Parameters from './Parameters';\nimport { forEach } from 'mathjs';\n\n\n\nexport class Model {\n    sets = [];\n\n    scene;\n    camera;\n    lighting;\n    bgColour;\n    controls;\n    lookAt;\n    tools;\n    renderer;\n\n    height;\n    width;\n\n    gridEnabled = false;\n    axesEnabled = false;\n    \n    \n    sidebarExpanded = false;\n\n    cameraType = 'perspective';\n    cameraPosition;\n\n    selectedSet;\n\n    planeConstants;\n    clippingPlanes;\n    clippingHelpers;\n    clipIntersections;\n    numOfObject;\n\n    constructor(chronometer, notify) {\n        this.scene = new Scene();\n        this.chronometer = chronometer;\n        this.setDefault();\n        this.notify = notify;\n       \n    }\n\n    /* GENERAL FUNCTIONS */\n\n    setDefault() {\n        \n        this.renderer = new WebGLRenderer({ antialias: false,powerPreference: \"high-performance\",preserveDrawingBuffer:true});\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n\n        this.videoFileloaded =true;\n        this.rotating = false;\n        this.cameraPostion = null;\n        this.lightHelperWarningGiven = false;\n        this.selectedSet = 0;\n        this.Video_sample_list=[];\n        this.clock = null;\n        this.initClippers();\n        this.lookAt = new Vector3(0, 0, 0);\n        this.updateDimensions();\n        this.setCamera(this.cameraType,true); \n        this.lighting = [\n            new Light('ambient'),\n            new Light('directional'),\n            new Light('point')];\n\n        this.tools = new ReferenceTools(50, 0xffffff);\n        this.bgColour = \"#000000\";\n        this.renderer.setClearColor(this.bgColour);\n\n        for (let l of this.lighting) {\n            this.scene.add(l.light);\n        }\n        this.scene.add(this.camera);\n        this.lod = 2;\n    }\n  \n    update() {\n        console.log('update called');\n        this.renderer.render(this.scene, this.camera);\n        if (!this.rotating) {\n            this.chronometer.click();\n        }\n    }\n    getRender_Object_number(){\n        let num =0;\n        this.scene.traverse( function(child) {\n             //@ts-ignore\n            if ( child.isMesh){\n                num = num+1;\n            };\n        } );\n       \n        this.numOfObject = (num-6);\n        console.log(this.numOfObject)\n    }\n    // occlusionCulling(){\n         \n    // const renderer = new WebGLRenderer();\n    // const gl = renderer.getContext();\n    // console.log(gl)\n    // const scene = new Scene();\n    // const mesh1 = new Mesh(new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( {color: 0x00ff00}));\n    // const mesh2 = new Mesh(new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( {color: 0x00ff00}));\n    // scene.add(mesh1, mesh2);\n    // var query = gl.createQuery();\n    // const camera = this.camera = new PerspectiveCamera(50, this.width / this.height, 0.1, 1000);\n      \n    // camera.position.z = 5;\n    // for (let l of this.lighting) {\n    //     scene.add(l.light);}\n    // gl.beginQuery(gl.ANY_SAMPLES_PASSED,query);\n    // renderer.render(scene, camera);\n    // gl.endQuery(gl.ANY_SAMPLES_PASSED,query);\n    // var result = gl.getQueryParameter(query,gl.QUERY_RESULT);\n    // console.log(Number(result));\n    // console.log(result)\n\n    getData() {\n        // To save config to download\n        let model = {};\n        let temp = {};\n        model.sets = [];\n        for (let set of this.sets) {\n            temp.name = set.name;\n            temp.orientationType = set.orientationType;\n            temp.positions = set.positions;\n            temp.orientations = set.orientations;\n            temp.unitBox = set.unitBox;\n            model.sets.push(temp);\n            temp = {};\n        }\n        return model;\n    }\n\n    toggleSidebar() {\n        this.sidebarExpanded = !this.sidebarExpanded;\n        this.updateDimensions();\n        this.updateCamera();\n        console.log(this.sidebarExpanded)\n    }\n\n    toggleAutorotate() {\n        this.controls.autoRotate = !this.controls.autoRotate;\n        this.rotating = !this.rotating;\n    }\n\n    getParameters(val) {\n        return Set.getParameters(val);\n    }\n\n    static rgbToHex(r, g, b) {\n        function componentToHex(c) {\n            var hex = c.toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        }\n        console.log(\"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b))\n        return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n\n    loadDeprecated(data) {\n        // placeholder FILE IO used for initial development\n        let particleSets = data.split(\"$\");\n        let setData, ps;\n        for (let particleSet of particleSets) {\n            if (particleSet === \"\") {\n                return;\n            }\n            else {\n                setData = particleSet.split(\"\\n\");\n                ps = new Set(setData[0], setData[1], setData.slice(2), this.clippingPlanes, this.clippingIntersections);\n                this.sets.push(ps);\n            }\n        }\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.add(m);\n            }\n        }\n    }\n\n    /* UPDATING SETS FUNCTIONS */\n\n    updateSets(id, params, f) {\n        for (const m of this.sets[id].meshes) {\n            this.scene.remove(m);\n            m.geometry.dispose();\n            m.material.dispose(); \n            m.dispose();\n        }\n        f(...params);\n        for (const m of this.sets[id].meshes) {\n            this.scene.add(m);\n        }\n        // let mesh = this.occlusionCulling();\n        // this.scene.add(mesh);\n    }\n\n    updateUserColour(id, colour) {\n        this.updateSets(id, [id, colour], (id, colour) => {\n            this.sets[id].meshes = [];\n            this.sets[id].setUserColour(Model.rgbToHex(colour.r, colour.g, colour.b));\n            this.sets[id].genMeshes();\n        });\n    }\n\n    updateShape(id, shape, parameters) {\n        this.updateSets(id, [id, shape, parameters], (id, shape, parameters) => {\n            this.sets[id].meshes = [];\n            this.sets[id].shapeType = shape;\n            this.sets[id].parameters = parameters.vals;\n            this.sets[id].genGeometries();\n            this.sets[id].setElements();\n            this.sets[id].genMeshes();\n        });\n    }\n\n    toggleWireframe(id, toggle) {\n        this.updateSets(id, [id, toggle], (id, toggle) => {\n            this.sets[id].meshes = [];\n            this.sets[id].wireframe = toggle;\n            this.sets[id].genMeshes();\n        });\n    }\n\n    toggleUserColour(id, toggle) {\n        this.updateSets(id, [id, toggle], (id, toggle) => {\n            this.sets[id].meshes = [];\n            this.sets[id].colourByDirector = toggle;\n            this.sets[id].genMeshes();\n        });\n    }\n\n    genSets(sets) {\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.remove(m);\n                m.geometry.dispose ();\n                m.material.dispose ();\n                m.dispose();\n            }\n        }\n        this.sets = [];\n        for (let setData of sets) {\n            this.sets.push(new Set(setData, this.clippingPlanes, this.clippingIntersections));\n        }\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.add(m);\n            }\n        }\n        this.getRender_Object_number();\n        \n    }\n\n    /* LOD FUNCTIONS */\n\n    getLOD() {\n        return this.lod;\n    }\n\n    updateLOD(val) {\n        this.lod = val;\n        for (let i = 0; i < this.sets.length; i++) {\n            this.updateSets(i, [i, val], (i, val) => {\n                this.sets[i].lod = val;\n                this.sets[i].meshes = [];\n                this.sets[i].genGeometries();\n                this.sets[i].setElements();\n                this.sets[i].genMeshes();\n            });\n        }\n    }\n\n\n    /* CAMERA AND PROJECTION FUNCTIONS */\n\n    updateDimensions() {\n        \n        this.height = (window.innerHeight - 56);\n\n        if (this.sidebarExpanded) {\n            this.width = window.innerWidth - 356;\n            console.log('sidebar')\n        } else {\n            this.width = window.innerWidth - 56;\n        }\n        this.renderer.setSize(this.width, this.height);\n    }\n\n    setCamera(type) {\n        console.log('set camera called')\n        if(this.camera){\n            this.camera='';\n        }\n        this.cameraType = type;\n        if (type === 'perspective') {\n            this.camera = new PerspectiveCamera(50, this.width / this.height, 0.1, 1000);\n        } else {\n            this.camera = new OrthographicCamera(this.width / -2, this.width / 2, this.height / 2, this.height / -2, -100, 5000);\n        }\n\n        if (this.cameraPosition != null) {\n            this.camera.position.set(...this.cameraPosition);\n        }\n        this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n        this.controls.target = this.lookAt;\n        // this.update();\n        \n        \n    }\n\n    updateCamera() {\n        if (this.cameraType === 'perspective') {\n            this.camera.aspect = this.width / this.height;\n        } else {\n            this.camera.left = this.width / - 2;\n            this.camera.right = this.width / 2;\n            this.camera.top = this.height / 2;\n            this.camera.bottom = this.height / - 2;\n        }\n        this.camera.updateProjectionMatrix();\n        this.update();\n    }\n\n    updateCameraZoom(val) {\n        this.camera.zoom = val;\n        this.camera.updateProjectionMatrix();\n    }\n\n    updateCameraPosition(p) {\n        this.cameraPosition = [p.x, p.y, p.z];\n        this.camera.position.set(p.x, p.y, p.z);\n        this.controls.update();\n    }\n\n    updateLookAt(l) {\n        this.lookAt = new Vector3(l.x, l.y, l.z);\n        this.controls.target = this.lookAt;\n        this.controls.update();\n\n    }\n\n    /* AMBIENT AND LIGHT FUNCTIONS */\n\n    updateBg(colour) {\n        this.bgColour = colour;\n        this.renderer.setClearColor(this.bgColour);\n    }\n\n    toggleLight(type, enabled) {\n        this.lighting[type].visible = enabled;\n    }\n\n    updateLight(type, colour) {\n        this.lighting[type].updateColour(Model.rgbToHex(colour.r, colour.g, colour.b), colour.i);\n        if (type != 0) {\n            this.lighting[type].helper.update();\n        }\n    }\n\n    toggleLightHelper(type, toggle) {\n        if (toggle) {\n            if (this.bgColour === '#ffffff' && !this.lightHelperWarningGiven) {\n                Alert.warning('If the background colour and light colour are the same, the light helper may not be visible.');\n                this.lightHelperWarningGiven = true;\n            }\n            this.lighting[type].helper.update();\n            this.scene.add(this.lighting[type].helper);\n        } else {\n            this.scene.remove(this.lighting[type].helper);\n        }\n    }\n\n    updateLightPosition(type, pos) {\n        this.lighting[type].updatePosition(pos.x, pos.y, pos.z);\n        this.lighting[type].helper.update();\n    }\n    /* PERIODIC BOUNDING TOOL FUNCTIONS */\n\n    toggleFoldState(id,toggle){\n        if(toggle===true){\n            this.updateSets(id, [id], (id) => {\n                this.sets[id].elements =[];\n                this.sets[id].meshes = [];\n                this.sets[id].genFoldedPositionFromUnfold();\n                this.sets[id].genElements();\n                this.sets[id].setElements();\n                this.sets[id].genMeshes();\n            });}\n        else if(toggle === false){\n            this.updateSets(id, [id], (id) => {\n                this.sets[id].elements =[];\n                this.sets[id].meshes = [];\n                this.sets[id].Folded_position =[];\n                this.sets[id].genElements();\n                this.sets[id].setElements();\n                this.sets[id].genMeshes();\n            });\n        }\n    }\n    // toggleUnfoldState(id,toggle){\n    //     if(toggle){\n    //         this.updateSets(id, [id], (id) => {\n    //             this.sets[id].elements =[];\n    //             this.sets[id].meshes = [];\n    //             this.sets[id].genUnfoldPosition();\n    //             this.sets[id].genElements();\n    //             this.sets[id].setElements();\n    //             this.sets[id].genMeshes();\n    //         });\n    //     }\n    //     else if(toggle == false){\n    //         this.updateSets(id, [id], (id) => {\n    //             this.sets[id].elements =[];\n    //             this.sets[id].meshes = [];\n    //             this.sets[id].genFoldedPositionFromUnfold();\n    //             this.sets[id].genElements();\n    //             this.sets[id].setElements();\n    //             this.sets[id].genMeshes();\n    //         });\n    //     }\n    //}\n\n\n\n    /* REFERENCE TOOLS FUNCTIONS */\n\n    toggleGrid() {\n        this.gridEnabled = !this.gridEnabled;\n\n        if (this.gridEnabled) {\n            this.scene.add(this.tools.subGrid);\n        } else {\n            this.scene.remove(this.tools.subGrid);\n        }\n    }\n\n    toggleAxes() {\n        this.axesEnabled = !this.axesEnabled;\n\n        if (this.axesEnabled) {\n            for (let a of this.tools.axes) {\n                this.scene.add(a);\n            }\n        } else {\n            for (let a of this.tools.axes) {\n                this.scene.remove(a);\n            }\n        }\n\n\n    }\n\n    updateReferenceColour(rgb) {\n        let passGrid = false;\n        let passAxes = false;\n        let passShape = false;\n        if (this.gridEnabled) {\n            this.toggleGrid();\n            passGrid = true;\n        }\n        if (this.axesEnabled && !this.tools.multicolour) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n        if (this.boundingShapeEnabled) {\n            this.updateBoundingShape('', false);\n            passShape = true;\n        }\n        this.tools.updateColour(Model.rgbToHex(rgb.r, rgb.g, rgb.b));\n        if (passGrid) {\n            this.toggleGrid();\n        }\n        if (passAxes) {\n            this.toggleAxes();\n        }\n        if (passShape) {\n            this.updateBoundingShape(this.tools.boundingShapeType, true);\n            passShape = true;\n        }\n    }\n\n    toggleAxesMulticolour() {\n        let passAxes = false;\n        if (this.axesEnabled) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n        this.tools.toggleMulticolour();\n        if (passAxes) {\n            this.toggleAxes();\n        }\n    }\n\n    updateGridSize(size) {\n        let passGrid = false;\n        let passAxes = false;\n        if (this.gridEnabled) {\n            this.toggleGrid();\n            passGrid = true;\n        }\n        if (this.axesEnabled) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n\n        this.tools.updateSize(size);\n\n        if (passGrid) {\n            this.toggleGrid();\n        }\n        if (passAxes) {\n            this.toggleAxes();\n        }\n    }\n\n    updateBoundingShape(type, enabled) {\n        this.boundingShapeEnabled = enabled;\n        this.scene.remove(this.tools.boundingShape);\n        if (enabled) {\n            this.scene.add(this.tools.genBoundingShape(type, this.sets));\n        }\n    }\n\n    \n    \n\n    /* SLICING FUNCTIONS */\n    enableClipping(toggle,id){\n        if (toggle === true){\n            this.renderer.localClippingEnabled = true;\n            this.updateSets(id, [id], (id) => {\n                this.sets[id].elements =[];\n                this.sets[id].meshes = [];\n                this.sets[id].setBackFace(true);\n                this.sets[id].genElements();\n                this.sets[id].setElements();\n                this.sets[id].genMeshes();\n            });\n        }\n        else{\n            this.renderer.localClippingEnabled = false;\n            // if (this.sets){\n            //     console.log('called')\n            //     this.updateSets(id, [id], (id) => {\n            //         this.sets[id].elements =[];\n            //         this.sets[id].meshes = [];\n            //         this.sets[id].setBackFace(false);\n            //         this.sets[id].genElements();\n            //         this.sets[id].setElements();\n            //         this.sets[id].genMeshes();\n            //     });\n            // }\n            \n        }\n        \n      \n    }\n\n    // disableClipping(){\n    //     this.renderer.localClippingEnabled = false;\n    // }\n\n    initClippers() {\n        this.clippingIntersections = false;\n        \n   \n        this.clippingPlanes = [\n            new Plane(new Vector3(1, 0, 0), 180),\n            new Plane(new Vector3(-1, 0, 0), 180),\n            new Plane(new Vector3(0, 1, 0), 180),\n            new Plane(new Vector3(0, -1, 0), 180),\n            new Plane(new Vector3(0, 0, 1), 180),\n            new Plane(new Vector3(0, 0, -1), 180)\n        ];\n       \n       this.clippingHelpers = [\n        new PlaneHelper(this.clippingPlanes[0], 100, 0xff0000),\n        new PlaneHelper(this.clippingPlanes[1], 100, 0xff0000),\n        new PlaneHelper(this.clippingPlanes[2], 100, 0x00ff00),\n        new PlaneHelper(this.clippingPlanes[3], 100, 0x00ff00),\n        new PlaneHelper(this.clippingPlanes[4], 100, 0x0000ff),\n        new PlaneHelper(this.clippingPlanes[5], 100, 0x0000ff)];\n\n        for (let helper of this.clippingHelpers) {\n            helper.visible = false;\n            this.scene.add(helper);\n        }\n\n        \n    }\n\n\n    \n    // }\n    toggleClipIntersection(toggle) {\n        for (let set of this.sets) {\n            set.toggleClipIntersection(toggle);\n        }\n    }\n\n    toggleHelper(i, toggle) {\n        this.clippingHelpers[2 * i].visible = toggle;\n        this.clippingHelpers[2 * i + 1].visible = toggle;\n    }\n\n    updateSlicer(i, vals) {\n        for (let set of this.sets) {\n            set.updateSlicers(i, vals);\n        }\n    }\n    /* Video SUITE */\n    setloaded(toggle){\n        console.log(toggle);\n    }\n    uploadConfig() {\n        return new Promise(async (resolve, reject) => {\n          let fileHandle = [];\n          let lst = [];\n          try {\n            fileHandle = await window.showOpenFilePicker({ multiple: true });\n            for (let i = 0; i < fileHandle.length; i++) {\n              const file = await fileHandle[i].getFile();\n              lst.push(file);\n            }\n            this.Video_sample_list = lst;\n            resolve(lst);\n          } catch (error) {\n            reject(error);\n          }\n        });\n    }\n\n    notifyFinishUpload(){\n        this.notify('info', `Files loaded successfully`,\n            (<div>\n            <p style={{ width: 320 }} >\n                Now Select Your Video Viewing configuration!\n                You can show unit box, apply slicing , periodic boundary conditions etc.\n                Please Do not change screen size while generating Video e.g dont click on size bar\n            </p>\n            </div>\n            ));\n            }\n    \n\n    retrieveVideoSample(){\n        return this.Video_sample_list;\n    }\n   removeVideoSample(){\n    delete this.Video_sample_list;\n   }\n    /* PERFORMANCE TEST SUITE */\n\n\n    initTesting(step) {\n        // set desirable testing view\n        this.setCamera('orthographic',false);\n        this.updateCameraZoom(8);\n        this.updateLightPosition(2, { x: 50, y: 0, z: 50 });\n        this.deleteAllMeshes();\n        this.testMaterial = new MeshLambertMaterial();\n        this.testShape = new SHAPE.Preset('Torus', Parameters.Torus.vals);\n        this.testShape.LOD = 2;\n        this.testShape.generate();\n        this.testTotal = 0;\n        this.testLimit = 500001;\n\n        this.notify('info', 'Initialising Performance Test',\n            (<p style={{ width: 320 }} >\n                Test Size: {this.testLimit.toString()} <br />\n            Step: {step.toString()} <br />\n            Shape: Torus (Default Parameters) <br />\n            Level of Detail: {(this.testShape.LOD + 1).toString()} <br />\n            Material: MeshPhongMaterial\n                <br/> <br/>\n            <b>Please do not change any settings while the performance test is running!</b>\n            </p>));\n\n        console.log('Material: MeshLambertMaterial')\n        console.log('Shape: Ellipsoid (Default Parameters)')\n        console.log('LOD: ' + (this.testShape.LOD + 1).toString())\n        console.log('Test Size: ' + this.testLimit.toString)\n        console.log('Test Step: ' + step.toString());\n    }\n\n    deleteAllMeshes() {\n        for( const set of this.sets){\n            console.log(set)\n            for (const m of set.meshes) {\n                this.scene.remove(m);\n                m.geometry.dispose();\n                m.material.dispose(); \n                m.dispose();\n            }\n\n        }\n       \n    }\n\n    addRandomParticles(n) {\n\n        this.testTotal += n;\n\n        if (this.testTotal >= this.testLimit) {\n            return true;\n        }\n\n        let geoms = [];\n        let m;\n        \n\n        if (this.testShape.isPreset) {\n            geoms.push(this.testShape.presetGeometry.clone());\n        }\n        else {\n            geoms.push(this.testShape.stripGeometry.clone());\n            geoms.push(this.testShape.fanGeometries[0].clone());\n            geoms.push(this.testShape.fanGeometries[1].clone());\n        }\n\n        this.translate([Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50], geoms);\n        \n        let Intsancemesh1 = new InstancedMesh( geoms[0], this.testMaterial, n);\n        for ( let i = 0; i < n; i ++ ) {\n                const matrix = new Matrix4();\n                const position = new Vector3();\n                const rotation = new Euler();\n                const quaternion = new Quaternion();\n                const scale = new Vector3();\n                const color = new Color();\n\t\t\t\tposition.x = Math.random() * 40 - 20;\n\t\t\t\tposition.y = Math.random() * 40 - 20;\n\t\t\t\tposition.z = Math.random() * 40 - 20;\n\n\t\t\t\trotation.x = Math.random() * 2 * Math.PI;\n\t\t\t\trotation.y = Math.random() * 2 * Math.PI;\n\t\t\t\trotation.z = Math.random() * 2 * Math.PI;\n\n\t\t\t\tquaternion.setFromEuler( rotation );\n\n\t\t\t\tscale.x = scale.y = scale.z = Math.random() * 1;\n\n\t\t\t\tmatrix.compose( position, quaternion, scale );\n                Intsancemesh1.setMatrixAt( i, matrix );\n                Intsancemesh1.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );\n        }\n        this.scene.add(Intsancemesh1);\n        // this.renderer.render(this.scene,this.camera);\n        geoms = [];\n    \n\n\n        return false;\n    }\n\n    translate(pos, geoms) {\n        for (let g of geoms) {\n            g.translate(pos[0], pos[1], pos[2]);\n        }\n    }\n\n}\n\n\nexport default Model;\n","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/View.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/ReferenceTools.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Set.js",["69","70","71","72","73","74","75"],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Light.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Shapes.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Parameters.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/VisualisationMenu.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/GeneralMenu.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/Tools.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/SubMenus.js",["76","77","78"],"\nimport { Nav, Divider, Checkbox, FormGroup, RadioGroup, Radio, Grid, Row, Col, Alert, Whisper, Tooltip, Icon,Input } from 'rsuite';\nimport React from \"react\";\nimport { SliceSlider, ParameterInput, ParameterSet, CustomSlider } from './Tools'\nimport {View} from './View.js'\n\nimport ccapture from \"ccapture.js-npmfixed\";\nimport { Scrollbars } from 'rc-scrollbars';\n\nconst TITLE_LEFT_MARGIN = 30;\nconst dividerStyle = {\n    color: '#A4A9A3'\n}\n\nconst submenuParameterSetStyling = [\n    { width: 130, marginLeft: 10 },\n    { marginTop: 10, marginLeft: 30 }\n];\n\nexport class ModelsOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.model;\n        this.model = props.model;\n        this.model.deleteAllMeshes();\n        this.selectShape = this.selectShape.bind(this);\n        this.selectSet = this.selectSet.bind(this);\n        this.updateParameter = this.updateParameter.bind(this);\n        this.toggleWireframe = this.toggleWireframe.bind(this);\n        this.toggleColour = this.toggleColour.bind(this);\n        this.updateUserColour = this.updateUserColour.bind(this);\n    }\n\n\n    updateUserColour(val, type) {\n        let colour = this.state.configurations[this.state.active].colour;\n\n        switch (type) {\n            case 'r':\n                colour.r = parseInt(val);\n                break;\n            case 'g':\n                colour.g =  parseInt(val);\n                break;\n            case 'b':\n                colour.b =  parseInt(val);\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n        this.model.updateUserColour(this.state.active, colour);\n        this.model.update();\n        View.state.model.configurations[this.state.active].colour = colour;\n    }\n\n    toggleColour() {\n        let toggle = !this.state.configurations[this.state.active].colourFromDirector;\n        this.setState({\n            colourFromDirector: toggle\n        });\n        View.state.model.configurations[this.state.active].colourFromDirector = toggle;\n        this.model.toggleUserColour(this.state.active, toggle);\n        this.model.update();\n    }\n\n    toggleWireframe() {\n        let toggle = !this.state.configurations[this.state.active].displayAsWireframe;\n        this.setState({\n            displayAsWireframe: toggle\n        });\n        View.state.model.configurations[this.state.active].displayAsWireframe = toggle;\n        this.model.toggleWireframe(this.state.active, toggle);\n        this.model.update();\n    }\n\n    updateParameter(val, i) {\n        if (isNaN(val) ||!val) {\n            val =0\n        }\n        const parameter = parseFloat(val);\n        let globalState = View.state.model.configurations[this.state.active];\n        globalState.parameters.vals[i] = parameter;\n\n        let configs = this.state.configurations;\n        configs[this.state.active].parameters.vals[i] = parameter;\n\n        this.setState({\n            configurations: configs\n        });\n\n        this.model.updateShape(this.state.active, globalState.shape, globalState.parameters);\n        this.model.update();\n        this.reset();\n    }\n\n    reset() {\n        let i;\n        if (this.state.reset > 50) {\n            i = 0;\n        } else {\n            i = this.state.reset;\n        }\n        this.setState(\n            {\n                reset: ++i\n            }\n        );\n    }\n\n    selectSet(val) {\n        for (let i = 0; i < this.state.sets.length; i++) {\n            if (this.state.sets[i].localeCompare(val) === 0) {\n                this.setState({\n                    active: i\n                })\n                View.state.model.active = i;\n                break;\n            }\n        }\n        this.reset();\n    }\n\n    selectShape(val) {\n        let parameters = this.model.getParameters(val);\n        this.setState(\n            {\n                shape: val,\n                parameters: parameters\n            }\n        );\n        this.reset();\n        View.state.model.configurations[this.state.active].shape = val;\n        View.state.model.configurations[this.state.active].parameters = parameters;\n        this.model.updateShape(this.state.active, val, parameters);\n        this.model.update();\n    }\n\n    render() {\n        const configState = this.state.configurations[this.state.active];\n        const reset = this.state.reset;\n        const title = configState.title;\n        const shapes = [\"Ellipsoid\", \"Sphere\", \"Spherocylinder\", \"Spheroplatelet\", \"Cut Sphere\", \"Cylinder\", \"Torus\"];\n        const sets = this.state.sets;\n\n        return (\n            <Scrollbars  style={{height:800}}>\n            <div key={reset} >\n                <Divider><strong style={dividerStyle}> Configuration</strong></Divider>\n                <ParameterInput key ={5}f={this.selectSet} selectingSet title=\"Set\" values={sets} active={title} styling={submenuParameterSetStyling} />\n                <ParameterInput key ={6}f={this.selectShape} title=\"Shape\" values={shapes} active={configState.shape} styling={submenuParameterSetStyling} />\n                <ParameterSet f={this.updateParameter} titles={configState.parameters.names} values={configState.parameters.vals} step={0.1} positive styling={submenuParameterSetStyling} />\n                <br />\n                <Divider><strong style={dividerStyle}>  Material </strong></Divider>\n\n                <Row className=\"show-grid\">\n                    <Col xs={1} />\n                    <Col xs={20}>\n                        <Checkbox checked={configState.displayAsWireframe} onClick={this.toggleWireframe}> Display as Wireframe </Checkbox>\n                        <Checkbox checked={configState.colourFromDirector} onClick={this.toggleColour}> Colour from Director </Checkbox>\n                        <br />\n                    </Col>\n                </Row>\n\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider f={this.updateUserColour} disabled={configState.colourFromDirector} boundaries={[0, 255]} val={configState.colour.r} type={'r'} />\n                <CustomSlider f={this.updateUserColour} disabled={configState.colourFromDirector} boundaries={[0, 255]} val={configState.colour.g} type={'g'} />\n                <CustomSlider f={this.updateUserColour} disabled={configState.colourFromDirector} boundaries={[0, 255]} val={configState.colour.b} type={'b'} />\n            </div>\n            </Scrollbars>\n        );\n    }\n}\n\nexport class VideoOptions extends React.Component{\n    constructor(props){\n        super();\n        this.model = props.model;\n        this.state =View.state.reference;\n        this.functions = props.functions;\n        this.toggler = props.toggler;\n        this.setfps = this.setfps.bind(this);\n        this.UploadFiles = this.UploadFiles.bind(this);\n        this.RealTimeVideo = this.RealTimeVideo.bind(this);\n        this.VideoToggle = this.VideoToggle.bind(this);\n        this.setVideoState = this.setVideoState.bind(this);\n        this.state.filename = 'WebMGA-Video.webm';\n        this.setFileName = this.setFileName.bind(this);\n\n    }\n    setFileName (val){\n        this.setState({\n            filename:val\n        })\n    }\n    setfps(val){\n     this.setState({\n        fps:val\n     })\n     View.state.reference.fps = val;\n    }\n    UploadFiles(){\n        let toggle = ! this.state.uploaded;\n        this.setState({\n            uploaded: toggle\n        })\n        if (toggle === true){\n            async function runAfterUpload(model, functions) {\n                const lst = await model.uploadConfig();\n                functions[1](lst[0],true,0);\n            }\n            runAfterUpload(this.model,this.functions).then(()=>{\n                this.model.notifyFinishUpload();\n            })\n        }\n        else{\n            this.model.Video_sample_list =[];\n        }\n        \n        View.state.reference.uploaded= !View.state.reference.uploaded;\n    }\n    setVideoState(){\n        var data = this.functions[5]();\n        this.state.vidstate  = data;\n        let toggle = ! this.state.loadVideoState\n        this.setState({\n            loadVideoState :toggle\n        })\n        View.state.reference.loadVideoState =!View.state.reference.loadVideoState;  \n    }\n    VideoToggle(){\n        console.log(this.state.video);\n        let toggle = !this.state.video;\n        this.setState({\n            video:toggle\n        })\n        this.state.video = toggle;\n        console.log(toggle)\n        if(toggle ===true){\n            this.toggler.closeSidemenu();\n            const samples = this.model.retrieveVideoSample();\n            const max_iter = samples.length;\n            var capturer = new ccapture( { format: 'webm',framerate:this.state.fps,quality:100});\n            this.RealTimeVideo(0,samples,max_iter,capturer,this.state.vidstate ,this.state.filename);\n            \n        }\n        View.state.reference.video = !View.state.reference.video\n    }\n    \n    RealTimeVideo(i,samples,max_iter,capturer,vidState,filename){\n        if(i ===0){\n            console.log('does this work?')\n            capturer.start();\n            capturer.capture(this.model.renderer.domElement);\n        }\n        if(i<max_iter){\n            console.log('start render')\n            this.functions[1].bind(this)(samples[i],i,vidState);\n            capturer.capture( this.model.renderer.domElement )\n            console.log('running animation',i)\n            if(this.state.video === true ){\n                requestAnimationFrame( ()=> this.RealTimeVideo(i+1,samples,max_iter,capturer,vidState,filename));\n                console.log('sending request',i+1)\n            };\n        }\n        if (i === max_iter){\n                console.log('max')\n                capturer.stop();\n                capturer.save(function( blob ) {\n                    console.log(blob);\n                    var url = URL.createObjectURL(blob);\n                    var link = document.createElement('a');\n                    link.href = url;\n                    console.log(filename)\n                    link.download = filename + '.webm';\n                    document.body.appendChild(link);\n                    link.click();\n                    document.body.removeChild(link);\n                });\n                View.state.reference.video =false;\n                View.state.reference.setVideoState = false;\n                \n        }}\n\n\n    render(){\n        const video = this.state.video;\n        const upload = this.state.uploaded;\n        const setVideoState = this.state.loadVideoState;\n        const fps = this.state.fps;\n        return(\n            <div>\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Load Configurations </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={upload} onClick={this.UploadFiles} > Load </Checkbox>\n                        </Col>\n                    </Row>\n    \n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Set Frame Rate</b></p>\n                        </Col>\n                    </Row>\n                    <CustomSlider boundaries={[1,60]} val={fps} f={this.setfps}type={'fps'} />\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Enviroment set up  </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox onClick={this.setVideoState} checked={setVideoState}>Apply </Checkbox>\n                        </Col>\n                        <Col xs={1}>\n                            <Whisper placement=\"bottom\" trigger=\"hover\" speaker={\n                                <Tooltip>\n                                    Modify enviromental set ups such as show unit box at other menus.\n                                    Toggle Apply to apply settings to Video.\n                            </Tooltip>\n                            }>\n                                <Icon style={{ marginTop: 8 }} icon=\"question-circle\" size=\"lg\" />\n                            </Whisper>\n                        </Col>\n                    </Row>\n                   \n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Create Video </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                        <p>Input File name:</p>\n                        <Input style={{ width:150,height:30,marginLeft: 20 }} placeholder=\"New_Video\" \n                            onChange={(filename) => this.setFileName(filename)}/>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox onClick={this.VideoToggle} checked={video} disabled={!upload||!setVideoState}> Create </Checkbox>\n                        </Col>\n                   </Row>\n                   \n                </Grid>\n                <br />\n                <br />\n            </div>\n\n        )\n    }\n}\n\n\n\nexport class CameraOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.camera;\n        this.model = props.model;\n        this.toggler = props.toggler;\n        this.selectType = this.selectType.bind(this);\n        this.updateLookat = this.updateLookat.bind(this);\n        this.updatePosition = this.updatePosition.bind(this);\n        this.updateZoom = this.updateZoom.bind(this);\n        this.updateState = this.updateState.bind(this);\n        \n        this.toggler.updateCamera = () => {\n            this.updateState()\n        }\n    }\n\n    updateState(){\n        this.setState(View.state.camera);\n    }\n\n    updateZoom(val) {\n        this.setState({\n            zoom: val\n        });\n        this.model.updateCameraZoom(parseInt(val));\n        this.model.update();\n        View.state.camera.zoom = val;\n    }\n\n    selectType(val) {\n        this.setState({\n            type: val\n        });\n        View.state.camera.type = val;\n        this.model.setCamera(val,false);\n        if (val === \"orthographic\") {\n            this.updateZoom(50);\n        } else {\n            this.updateZoom(1);\n        }\n\n    }\n\n    updatePosition(val, type) {\n        let position = this.state.position;\n        if (val != isNaN && val != null) {\n            switch (type) {\n                case 'x':\n                    position.x = parseInt(val);\n                    break;\n                case 'y':\n                    position.y = parseInt(val);\n                    break;\n                case 'z':\n                    position.z = parseInt(val);\n                    break;\n                default:\n                    Alert.error('Error: Unexpected Camera Position Input');\n                    return;\n            }\n        }\n\n        this.model.updateCameraPosition(position);\n        this.model.update();\n        View.state.camera.position = position;\n    }\n\n    updateLookat(val, type) {\n        let lookAt = this.state.lookAt;\n\n        if (isNaN(val) ||!val) {\n            val =0\n        }\n        switch (type) {\n            case 0:\n                lookAt.x = parseFloat(val);\n                break;\n            case 1:\n                lookAt.y = parseFloat(val);\n                break;\n            case 2:\n                lookAt.z = parseFloat(val);\n                break;\n            default:\n                Alert.error('Error: Unexpected Look At Input');\n                return;\n        }\n\n        this.model.updateLookAt(lookAt);\n        this.model.update();\n        View.state.camera.lookAt = lookAt;\n    }\n\n\n    render() {\n        const cameraType = this.state.type;\n        const zoom = this.state.zoom;\n        const lookAt = [this.state.lookAt.x, this.state.lookAt.y, this.state.lookAt.z];\n        const cameraPosition = this.state.position;\n\n\n        return (\n            <div key={JSON.stringify(this.state)}>\n                <br />\n                <Row className=\"show-grid\">\n                    <Col xs={2} />\n                    <Col xs={12}>\n\n                        <FormGroup controlId=\"radioList\">\n                            <RadioGroup name=\"radioList\" value={cameraType} onChange={this.selectType}>\n                                <p><b>Type</b></p>\n                                <Radio value=\"perspective\">Perspective </Radio>\n                                <Radio value=\"orthographic\">Orthographic </Radio>\n                            </RadioGroup>\n                        </FormGroup>\n\n                    </Col>\n                </Row>\n\n                <Grid fluid>\n\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Position</b></p>\n                        </Col>\n                    </Row>\n\n                    <CustomSlider boundaries={[-50, 50]} val={cameraPosition.x} f={this.updatePosition} type={'x'} />\n                    <CustomSlider boundaries={[-50, 50]} val={cameraPosition.y} f={this.updatePosition} type={'y'} />\n                    <CustomSlider boundaries={[-50, 50]} val={cameraPosition.z} f={this.updatePosition} type={'z'} />\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Zoom </b></p>\n                        </Col>\n                    </Row>\n                    <CustomSlider key={cameraType} boundaries={[1, 100]} val={zoom} f={this.updateZoom} />\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Look at</b></p>\n                        </Col>\n                    </Row>\n                    <ParameterSet titles={[\"x\", \"y\", \"z\"]} values={lookAt} f={this.updateLookat} step={0.5} styling={submenuParameterSetStyling} />\n\n                </Grid>\n                <br />\n\n\n\n            </div>);\n    }\n}\n\nexport class SlicingOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.slicing\n        this.model = props.model;\n        this.toggleSlicer = this.toggleSlicer.bind(this);\n        this.toggleHelperX = this.toggleHelperX.bind(this);\n        this.toggleHelperY = this.toggleHelperY.bind(this);\n        this.toggleHelperZ = this.toggleHelperZ.bind(this);\n        this.updateHelpers = this.updateHelpers.bind(this);\n        this.updateSlicer = this.updateSlicer.bind(this);\n        console.log(this.state,View.state.slicing);\n    }\n\n    toggleSlicer(){\n        let toggle = !this.state.slicing_enabled;\n        this.model.enableClipping(toggle,View.state.model.active);\n        this.setState({\n            slicing_enabled :toggle\n        })\n        View.state.slicing.slicing_enabled = toggle\n        console.log(this.state,View.state.slicing);\n    }\n\n    updateHelpers(helpers) {\n        this.setState(\n            {\n                helpers: helpers\n            }\n        );\n        View.state.slicing.helpers = helpers;\n    }\n\n    toggleHelperX() {\n        let helpers = this.state.helpers;\n        let toggle = !helpers[0];\n        helpers[0] = toggle;\n        this.updateHelpers(helpers);\n        this.model.toggleHelper(0, toggle);\n        this.model.update();\n    }\n\n    toggleHelperY() {\n        let helpers = this.state.helpers;\n        let toggle = !helpers[1];\n        helpers[1] = toggle;\n        this.updateHelpers(helpers);\n        this.model.toggleHelper(1, toggle);\n        this.model.update();\n    }\n\n    toggleHelperZ() {\n        let helpers = this.state.helpers;\n        let toggle = !helpers[2];\n        helpers[2] = toggle;\n        this.updateHelpers(helpers);\n        this.model.toggleHelper(2, toggle);\n        this.model.update();\n    }\n\n    updateSlicer(i, val) {\n    \n        switch (i) {\n            case 0:\n                this.setState(\n                    {\n                        x:val\n                    }\n                );\n                // this.state.x = val;\n                break;\n            case 1:\n                this.setState(\n                    {\n                        y:val\n                    }\n                );\n                // this.state.y = val;\n                break;\n            case 2:\n                this.setState(\n                    {\n                        z:val\n                    }\n                );\n                // this.state.z = val;\n                break;\n            default:\n                Alert.error('Error: Unexpected Slicing Identifier');\n        }\n        \n        \n\n        this.model.updateSlicer(i, val);\n        this.model.update();\n    }\n    render() {\n        const state = this.state;\n        const slicing_enabled = this.state.slicing_enabled;\n        return (\n            <div>\n                <br />\n                <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Enable Slicing</b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked={slicing_enabled}onClick={this.toggleSlicer}> enable </Checkbox>\n                        </Col>\n                    </Row>\n                <SliceSlider title=\"X : \" f={this.updateSlicer} index={0} vals={state.x} disabled={!slicing_enabled}/>\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={state.helpers[0]} onClick={this.toggleHelperX}> Show Helper</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n                <SliceSlider title=\"Y : \" f={this.updateSlicer} index={1} vals={state.y} />\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={state.helpers[1]} onClick={this.toggleHelperY}> Show Helper</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n                <SliceSlider title=\"Z : \" f={this.updateSlicer} index={2} vals={state.z} />\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={state.helpers[2]} onClick={this.toggleHelperZ}> Show Helper</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n            </div>\n        );\n    }\n\n}\n\n\n      \n\n\nexport const AdditionalLightsNav = ({ active, onSelect }) => {\n    return (\n        <Nav activeKey={active} onSelect={onSelect} style={{ margin: 10, width: 280 }} justified appearance=\"tabs\">\n            <Nav.Item eventKey=\"point\">Point</Nav.Item>\n            <Nav.Item eventKey=\"directional\">Directional</Nav.Item>\n        </Nav>\n    );\n};\n\nexport class AdditionalLightOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.pointLight;\n        this.model = props.model;\n        this.reset = 0;\n        this.handleSelect = this.handleSelect.bind(this);\n        this.updateColour = this.updateColour.bind(this);\n        this.updatePosition = this.updatePosition.bind(this);\n        this.toggleLightEnabled = this.toggleLightEnabled.bind(this);\n        this.toggleHelper = this.toggleHelper.bind(this);\n\n    }\n    handleSelect() {\n        if (this.state.active.localeCompare('point') === 0) {\n            this.setState(View.state.directionalLight);\n        } else {\n            this.setState(View.state.pointLight);\n        }\n        if (this.reset > 5) {\n            this.reset = 0;\n        }\n\n        this.setState({ reset: ++this.reset });\n    }\n\n    toggleHelper() {\n        let helper = !this.state.helper;\n        this.setState({\n            helper: helper\n        });\n\n        if (this.state.active.localeCompare('point') === 0) {\n            View.state.pointLight.helper = helper;\n            this.model.toggleLightHelper(2, helper);\n            this.model.update();\n        } else {\n            View.state.directionalLight.helper = helper;\n            this.model.toggleLightHelper(1, helper);\n            this.model.update();\n        }\n    }\n\n    toggleLightEnabled() {\n        let enabled = !this.state.enabled;\n        this.setState({\n            enabled: enabled\n        });\n        let intensity;\n        if (this.state.active.localeCompare('point') === 0) {\n            View.state.pointLight.enabled = enabled;\n            intensity = View.state.pointLight.colour.i;\n        } else {\n            View.state.directionalLight.enabled = enabled;\n            intensity = View.state.directionalLight.colour.i;\n        }\n\n        if (enabled) {\n            this.updateColour(intensity, 'i');\n        } else {\n            this.updateColour(0, 'i');\n        }\n        this.setState({ reset: ++this.reset });\n\n        if (this.state.active.localeCompare('point') === 0) {\n            View.state.pointLight.colour.i = intensity;\n        } else {\n            View.state.directionalLight.colour.i = intensity;\n        }\n    }\n\n    updateColour(val, type) {\n        let colour = this.state.colour;\n\n        switch (type) {\n            case 'r':\n                colour.r = val;\n                break;\n            case 'g':\n                colour.g = val;\n                break;\n            case 'b':\n                colour.b = val;\n                break;\n            case 'i':\n                colour.i = val;\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n\n        if (this.state.active.localeCompare('point') === 0) {\n            this.model.updateLight(2, colour);\n            View.state.pointLight.colour = colour;\n        } else {\n            this.model.updateLight(1, colour);\n            View.state.directionalLight.colour = colour;\n        }\n        this.model.update();\n    }\n    updatePosition(val, type) {\n        let position = this.state.position;\n\n        switch (type) {\n            case 'x':\n                position.x = val;\n                break;\n            case 'y':\n                position.y = val;\n                break;\n            case 'z':\n                position.z = val;\n                break;\n            default:\n                Alert.error('Error: Unexpected Position Identifier');\n        }\n\n        if (this.state.active.localeCompare('point') === 0) {\n            this.model.updateLightPosition(2, position);\n            View.state.pointLight.position = position;\n        } else {\n            this.model.updateLightPosition(1, position);\n            View.state.directionalLight.position = position;\n        }\n        this.model.update();\n    }\n\n    render() {\n        const active = this.state.active;\n        const lightState = this.state;\n        return (\n            <div key={lightState.reset}>\n                <br />\n                <AdditionalLightsNav active={active} onSelect={this.handleSelect} />\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={lightState.enabled} onClick={this.toggleLightEnabled}> <strong>Enabled </strong> </Checkbox>\n                            <Checkbox checked={lightState.helper} onClick={this.toggleHelper}> <strong>Show Helper </strong> </Checkbox>\n                            <br />\n                        </Col>\n                    </Row>\n                </Grid>\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 255]} val={lightState.colour.r} f={this.updateColour} type={'r'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 255]} val={lightState.colour.g} f={this.updateColour} type={'g'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 255]} val={lightState.colour.b} f={this.updateColour} type={'b'} />\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> Intensity </p>\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 100]} val={lightState.colour.i} f={this.updateColour} type={'i'} />\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> Position XYZ </p>\n                <CustomSlider disabled={!lightState.enabled} boundaries={[-50, 50]} val={lightState.position.x} f={this.updatePosition} type={'x'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[-50, 50]} val={lightState.position.y} f={this.updatePosition} type={'y'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[-50, 50]} val={lightState.position.z} f={this.updatePosition} type={'z'} />\n            </div>\n        );\n    }\n}\n\nexport class AmbientLightOptions extends React.Component {\n    constructor(props) {\n        super();\n\n        this.state = View.state.ambientLight;\n\n        this.model = props.model;\n\n        this.updateColour = this.updateColour.bind(this);\n        this.updateBg = this.updateBg.bind(this);\n    }\n    updateColour(val, i) {\n        let colour = this.state.ambientLightColour;\n\n        switch (i) {\n            case 'r':\n                colour.r = val;\n                break;\n            case 'g':\n                colour.g = val;\n                break;\n            case 'b':\n                colour.b = val;\n                break;\n            case 'i':\n                colour.i = val;\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n        this.model.updateLight(0, colour);\n        this.model.update();\n        View.state.ambientLight.ambientLightColour = colour;\n    }\n    updateBg() {\n        console.log(this.state.darkBackGround)\n        let toggle = !this.state.darkBackGround;\n        this.setState({\n            darkBackGround:toggle\n        })\n        console.log(this.state.darkBackGround)\n        if (toggle === true){\n            this.model.updateBg(\"#000000\");\n        }\n        else{\n            this.model.updateBg('#FFFFFF');\n        }\n        this.model.update();\n        View.state.ambientLight.darkBackGround = !View.state.ambientLight.darkBackGround;\n       \n    }\n    render() {\n        const ambientLightColour = this.state.ambientLightColour;\n        const backgroundColour = this.state.darkBackGround;\n        return (\n            <div>\n                <Divider><strong style={dividerStyle}> Ambient Light </strong></Divider>\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={ambientLightColour.r} f={this.updateColour} type={'r'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={ambientLightColour.g} f={this.updateColour} type={'g'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={ambientLightColour.b} f={this.updateColour} type={'b'} />\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> Intensity </p>\n                <CustomSlider disabled={false} boundaries={[0, 100]} val={ambientLightColour.i} f={this.updateColour} type={'i'} />\n                <Divider><strong style={dividerStyle}> Background Colour</strong></Divider>\n                <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked ={backgroundColour} onClick={this.updateBg}> Dark Mode</Checkbox>\n                        </Col>\n                </Row>\n            </div>\n        );\n    }\n}\n   \nexport class ReferenceOptions extends React.Component {\n    constructor(props) {\n        super();\n        this.state = View.state.reference;\n        this.state.model = View.state.model;\n        this.model = props.model;\n        this.toggleFold = this.toggleFold.bind(this);\n        this.toggleBoundingShapeEnabled= this.toggleBoundingShapeEnabled.bind(this);\n        this.toggleAxes = this.toggleAxes.bind(this);\n\n        this.toggleMulticolour = this.toggleMulticolour.bind(this);\n\n    }\n   \n    toggleFold() {\n        let toggle = !this.state.model.configurations[this.state.model.active].displayFoldState;\n        this.setState({\n            displayFoldState: toggle\n        });\n        console.log(this.state.model);\n        View.state.model.configurations[this.state.model.active].displayFoldState = toggle;\n        this.model.toggleFoldState(this.state.model.active,toggle);\n        this.model.update();\n    }\n\n    toggleBoundingShapeEnabled() {\n        let toggle = !this.state.boundingShapeEnabled;\n        this.setState({\n            boundingShapeEnabled: toggle\n        });\n        this.model.updateBoundingShape(View.state.reference.activeShape, toggle);\n        this.model.update();\n        View.state.reference.boundingShapeEnabled = ! View.state.reference.boundingShapeEnabled;\n    }\n    \n\n    toggleMulticolour() {\n        this.setState({\n            multicolour: !this.state.multicolour\n        });\n        this.model.toggleAxesMulticolour();\n        this.model.update();\n        View.state.reference.multicolour = !View.state.reference.multicolour;\n    }\n    toggleAxes() {\n        this.setState({\n            showAxes: !this.state.showAxes\n        });\n        this.model.toggleAxes();\n        this.model.update();\n        \n        View.state.reference.showAxes = !View.state.reference.showAxes;\n    }\n\n\n    render() {\n        const configState = this.state.model.configurations[this.state.model.active];\n        const enabled = this.state.boundingShapeEnabled;\n        const showAxes = this.state.showAxes;\n        const multicolour = this.state.multicolour;\n        return (\n            <div>\n\n                <Grid fluid>\n                <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Unit Box </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked={enabled}onClick={this.toggleBoundingShapeEnabled}>  Show </Checkbox>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Periodic Boundary Conditions  </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked={configState.displayFoldState} onClick={this.toggleFold}> Fold</Checkbox>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Axes </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked={showAxes} onClick={this.toggleAxes}> Show</Checkbox>\n\n                        </Col>\n                    </Row>\n\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n\n                            <Checkbox style={{ marginLeft: 12 }} checked={multicolour} onClick={this.toggleMulticolour}> Multi-Colour</Checkbox>\n\n                        </Col>\n                        <Col xs={4}>\n                            <Whisper placement=\"bottom\" trigger=\"hover\" speaker={\n                                <Tooltip>\n                                    X : RED <br /> Y : GREEN <br /> Z : BLUE\n                            </Tooltip>\n                            }>\n                                <Icon style={{ marginTop: 8 }} icon=\"question-circle\" size=\"lg\" />\n                            </Whisper>\n                        </Col>\n                    </Row>\n                    \n\n\n                </Grid>\n               \n            </div>\n        );\n    }\n}\n",{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","severity":1,"message":"84","line":10,"column":5,"nodeType":"85","messageId":"86","endLine":10,"endColumn":9},{"ruleId":"83","severity":1,"message":"87","line":12,"column":5,"nodeType":"85","messageId":"86","endLine":12,"endColumn":22},{"ruleId":"83","severity":1,"message":"88","line":14,"column":5,"nodeType":"85","messageId":"86","endLine":14,"endColumn":16},{"ruleId":"83","severity":1,"message":"89","line":27,"column":10,"nodeType":"85","messageId":"86","endLine":27,"endColumn":17},{"ruleId":"90","severity":1,"message":"91","line":384,"column":18,"nodeType":"92","messageId":"93","endLine":384,"endColumn":20},{"ruleId":"83","severity":1,"message":"94","line":738,"column":13,"nodeType":"85","messageId":"86","endLine":738,"endColumn":14},{"ruleId":"83","severity":1,"message":"84","line":2,"column":5,"nodeType":"85","messageId":"86","endLine":2,"endColumn":9},{"ruleId":"83","severity":1,"message":"95","line":8,"column":5,"nodeType":"85","messageId":"86","endLine":8,"endColumn":15},{"ruleId":"83","severity":1,"message":"96","line":9,"column":5,"nodeType":"85","messageId":"86","endLine":9,"endColumn":9},{"ruleId":"83","severity":1,"message":"97","line":14,"column":10,"nodeType":"85","messageId":"86","endLine":14,"endColumn":29},{"ruleId":"90","severity":1,"message":"91","line":105,"column":35,"nodeType":"92","messageId":"93","endLine":105,"endColumn":37},{"ruleId":"90","severity":1,"message":"91","line":116,"column":36,"nodeType":"92","messageId":"93","endLine":116,"endColumn":38},{"ruleId":"98","severity":1,"message":"99","line":259,"column":21,"nodeType":"85","messageId":"100","endLine":259,"endColumn":24},{"ruleId":"101","severity":1,"message":"102","line":224,"column":9,"nodeType":"103","messageId":"104","endLine":224,"endColumn":19},{"ruleId":"101","severity":1,"message":"102","line":237,"column":9,"nodeType":"103","messageId":"104","endLine":237,"endColumn":19},{"ruleId":"90","severity":1,"message":"91","line":420,"column":17,"nodeType":"92","messageId":"93","endLine":420,"endColumn":19},"no-native-reassign",["105"],"no-negated-in-lhs",["106"],"no-unused-vars","'Mesh' is defined but never used.","Identifier","unusedVar","'MeshBasicMaterial' is defined but never used.","'BoxGeometry' is defined but never used.","'forEach' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'m' is defined but never used.","'Box3Helper' is defined but never used.","'Box3' is defined but never used.","'BufferGeometryUtils' is defined but never used.","no-redeclare","'ori' is already defined.","redeclared","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","noDirectMutation","no-global-assign","no-unsafe-negation"]