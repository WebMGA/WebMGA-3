[{"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/index.js":"1","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/App.js":"2","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Controller.js":"3","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Model.js":"4","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/View.js":"5","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/ReferenceTools.js":"6","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Set.js":"7","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Light.js":"8","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Shapes.js":"9","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Parameters.js":"10","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/VisualisationMenu.js":"11","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/GeneralMenu.js":"12","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/Tools.js":"13","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/SubMenus.js":"14"},{"size":198,"mtime":1676296895669,"results":"15","hashOfConfig":"16"},{"size":928,"mtime":1676296895626,"results":"17","hashOfConfig":"16"},{"size":13016,"mtime":1677857030556,"results":"18","hashOfConfig":"16"},{"size":17939,"mtime":1677773125473,"results":"19","hashOfConfig":"16"},{"size":6904,"mtime":1677857108124,"results":"20","hashOfConfig":"16"},{"size":4053,"mtime":1677543033679,"results":"21","hashOfConfig":"16"},{"size":15369,"mtime":1677772930107,"results":"22","hashOfConfig":"16"},{"size":1375,"mtime":1676296895628,"results":"23","hashOfConfig":"16"},{"size":24017,"mtime":1676296895633,"results":"24","hashOfConfig":"16"},{"size":654,"mtime":1676296895630,"results":"25","hashOfConfig":"16"},{"size":7045,"mtime":1677859796564,"results":"26","hashOfConfig":"16"},{"size":14744,"mtime":1677857052153,"results":"27","hashOfConfig":"16"},{"size":6305,"mtime":1677543033706,"results":"28","hashOfConfig":"16"},{"size":37120,"mtime":1677859387458,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"trfy6y",{"filePath":"33","messages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"32"},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"32"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"32"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"60","messages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/index.js",[],["62","63"],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/App.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Controller.js",["64","65","66"],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Model.js",["67","68","69","70","71","72","73"],"import {\n    Scene,\n    WebGLRenderer,\n    PerspectiveCamera,\n    OrthographicCamera,\n    Vector3,\n    PlaneHelper,\n    Plane,\n    MeshLambertMaterial,\n    MeshPhongMaterial,\n    MeshStandardMaterial,\n    Mesh\n} from 'three';\nimport * as THREE from 'three'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport Set from './Set.js'\nimport Light from './Light.js'\nimport ReferenceTools from './ReferenceTools.js'\nimport { Alert } from 'rsuite'\nimport * as SHAPE from './Shapes.js';\nimport Parameters from './Parameters';\n\n\nexport class Model {\n    sets = [];\n\n    scene;\n    camera;\n    lighting;\n    bgColour;\n    controls;\n    lookAt;\n    tools;\n    renderer;\n\n    height;\n    width;\n\n    gridEnabled = false;\n    axesEnabled = false;\n    \n    \n    sidebarExpanded = false;\n\n    cameraType = 'perspective';\n    cameraPosition;\n\n    selectedSet;\n\n    planeConstants;\n    clippingPlanes;\n    clippingHelpers;\n    clipIntersections;\n    \n\n    constructor(chronometer, notify) {\n        this.scene = new Scene();\n        this.chronometer = chronometer;\n        this.setDefault();\n        this.notify = notify;\n       \n    }\n\n    /* GENERAL FUNCTIONS */\n\n    setDefault() {\n        \n        this.renderer = new WebGLRenderer({ antialias: false, preserveDrawingBuffer: false, powerPreference: \"high-performance\"});\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n        this.renderer.localClippingEnabled = true;\n        this.renderer.setFaceCulling( THREE.CullFaceBack);\n        this.rotating = false;\n        this.cameraPostion = null;\n        this.lightHelperWarningGiven = false;\n        this.selectedSet = 0;\n        //this.removeclipping();\n        this.initClippers();\n\n        this.lookAt = new Vector3(0, 0, 0);\n\n        this.updateDimensions();\n        this.setCamera(this.cameraType);\n\n\n        this.lighting = [\n            new Light('ambient'),\n            new Light('directional'),\n            new Light('point')];\n\n        this.tools = new ReferenceTools(50, 0xffffff);\n        this.bgColour = \"#000000\";\n        this.renderer.setClearColor(this.bgColour);\n\n        for (let l of this.lighting) {\n            this.scene.add(l.light);\n        }\n        this.scene.add(this.camera);\n        this.lod = 2;\n    }\n\n    update() {\n        \n        this.renderer.render(this.scene, this.camera);\n        if (!this.rotating) {\n            this.chronometer.click();\n        }\n    }\n\n    getData() {\n        let model = {};\n        let temp = {};\n        model.sets = [];\n        for (let set of this.sets) {\n            temp.name = set.name;\n            temp.orientationType = set.orientationType;\n            temp.positions = set.positions;\n            temp.orientations = set.orientations;\n            temp.unitBox = set.unitBox;\n            model.sets.push(temp);\n            temp = {};\n        }\n        return model;\n    }\n\n    toggleSidebar() {\n        this.sidebarExpanded = !this.sidebarExpanded;\n        this.updateDimensions();\n        this.updateCamera();\n    }\n\n    toggleAutorotate() {\n        this.controls.autoRotate = !this.controls.autoRotate;\n        this.rotating = !this.rotating;\n    }\n\n    getParameters(val) {\n        return Set.getParameters(val);\n    }\n\n    static rgbToHex(r, g, b) {\n        function componentToHex(c) {\n            var hex = c.toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        }\n        return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n\n    loadDeprecated(data) {\n        // placeholder FILE IO used for initial development\n        let particleSets = data.split(\"$\");\n        let setData, ps;\n        for (let particleSet of particleSets) {\n            if (particleSet == \"\") {\n                return;\n            }\n            else {\n                setData = particleSet.split(\"\\n\");\n                ps = new Set(setData[0], setData[1], setData.slice(2), this.clippingPlanes, this.clippingIntersections);\n                this.sets.push(ps);\n            }\n        }\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.add(m);\n            }\n        }\n    }\n\n    /* UPDATING SETS FUNCTIONS */\n\n    updateSets(id, params, f) {\n        for (const m of this.sets[id].meshes) {\n            this.scene.remove(m);\n        }\n        f(...params);\n        for (const m of this.sets[id].meshes) {\n            this.scene.add(m);\n        }\n    }\n\n    updateUserColour(id, colour) {\n        this.updateSets(id, [id, colour], (id, colour) => {\n            this.sets[id].meshes = [];\n            this.sets[id].setUserColour(Model.rgbToHex(colour.r, colour.g, colour.b));\n            this.sets[id].genMeshes();\n        });\n    }\n\n    updateShape(id, shape, parameters) {\n        this.updateSets(id, [id, shape, parameters], (id, shape, parameters) => {\n            this.sets[id].meshes = [];\n            this.sets[id].shapeType = shape;\n            this.sets[id].parameters = parameters.vals;\n            this.sets[id].genGeometries();\n            this.sets[id].setElements();\n            this.sets[id].genMeshes();\n        });\n    }\n\n    toggleWireframe(id, toggle) {\n        this.updateSets(id, [id, toggle], (id, toggle) => {\n            this.sets[id].meshes = [];\n            this.sets[id].wireframe = toggle;\n            this.sets[id].genMeshes();\n        });\n    }\n\n    toggleUserColour(id, toggle) {\n        this.updateSets(id, [id, toggle], (id, toggle) => {\n            this.sets[id].meshes = [];\n            this.sets[id].colourByDirector = toggle;\n            this.sets[id].genMeshes();\n        });\n    }\n\n    genSets(sets) {\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.remove(m);\n            }\n        }\n        this.sets = [];\n        for (let setData of sets) {\n            this.sets.push(new Set(setData, this.clippingPlanes, this.clippingIntersections));\n        }\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.add(m);\n            }\n        }\n    }\n\n    /* LOD FUNCTIONS */\n\n    getLOD() {\n        return this.lod;\n    }\n\n    updateLOD(val) {\n        this.lod = val;\n        for (let i = 0; i < this.sets.length; i++) {\n            this.updateSets(i, [i, val], (i, val) => {\n                this.sets[i].lod = val;\n                this.sets[i].meshes = [];\n                this.sets[i].genGeometries();\n                this.sets[i].setElements();\n                this.sets[i].genMeshes();\n            });\n        }\n    }\n\n\n    /* CAMERA AND PROJECTION FUNCTIONS */\n\n    updateDimensions() {\n        this.height = (window.innerHeight - 56);\n\n        if (this.sidebarExpanded) {\n            this.width = window.innerWidth - 356;\n        } else {\n            this.width = window.innerWidth - 56;\n        }\n        this.renderer.setSize(this.width, this.height);\n    }\n\n    setCamera(type) {\n        this.cameraType = type;\n\n        if (type === 'perspective') {\n            this.camera = new PerspectiveCamera(50, this.width / this.height, 0.1, 1000);\n        } else {\n            this.camera = new OrthographicCamera(this.width / -2, this.width / 2, this.height / 2, this.height / -2, -100, 5000);\n        }\n\n        if (this.cameraPosition != null) {\n            this.camera.position.set(...this.cameraPosition);\n        }\n\n        this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n        this.controls.target = this.lookAt;\n        this.update();\n    }\n\n    updateCamera() {\n        if (this.cameraType === 'perspective') {\n            this.camera.aspect = this.width / this.height;\n        } else {\n            this.camera.left = this.width / - 2;\n            this.camera.right = this.width / 2;\n            this.camera.top = this.height / 2;\n            this.camera.bottom = this.height / - 2;\n        }\n        this.camera.updateProjectionMatrix();\n        this.update();\n    }\n\n    updateCameraZoom(val) {\n        this.camera.zoom = val;\n        this.camera.updateProjectionMatrix();\n    }\n\n    updateCameraPosition(p) {\n\n        this.cameraPosition = [p.x, p.y, p.z];\n        this.camera.position.set(p.x, p.y, p.z);\n        this.controls.update();\n    }\n\n    updateLookAt(l) {\n        this.lookAt = new Vector3(l.x, l.y, l.z);\n        this.controls.target = this.lookAt;\n        this.controls.update();\n\n    }\n\n    /* AMBIENT AND LIGHT FUNCTIONS */\n\n    updateBg(colour) {\n        this.bgColour = Model.rgbToHex(colour.r, colour.g, colour.b);\n        this.renderer.setClearColor(this.bgColour);\n    }\n\n    toggleLight(type, enabled) {\n        this.lighting[type].visible = enabled;\n    }\n\n    updateLight(type, colour) {\n        this.lighting[type].updateColour(Model.rgbToHex(colour.r, colour.g, colour.b), colour.i);\n        if (type != 0) {\n            this.lighting[type].helper.update();\n        }\n    }\n\n    toggleLightHelper(type, toggle) {\n        if (toggle) {\n            if (this.bgColour == '#ffffff' && !this.lightHelperWarningGiven) {\n                Alert.warning('If the background colour and light colour are the same, the light helper may not be visible.');\n                this.lightHelperWarningGiven = true;\n            }\n            this.lighting[type].helper.update();\n            this.scene.add(this.lighting[type].helper);\n        } else {\n            this.scene.remove(this.lighting[type].helper);\n        }\n    }\n\n    updateLightPosition(type, pos) {\n        this.lighting[type].updatePosition(pos.x, pos.y, pos.z);\n        this.lighting[type].helper.update();\n    }\n    /* PERIODIC BOUNDING TOOL FUNCTIONS */\n\n    toggleFoldState(id,toggle){\n        if(toggle==true){\n            this.updateSets(id, [id], (id) => {\n                this.sets[id].elements =[];\n                this.sets[id].meshes = [];\n                this.sets[id].genFoldedPositionFromUnfold();\n                this.sets[id].genElements();\n                this.sets[id].setElements();\n                this.sets[id].genMeshes();\n            });}\n        else if(toggle == false){\n            this.updateSets(id, [id], (id) => {\n                this.sets[id].elements =[];\n                this.sets[id].meshes = [];\n                this.sets[id].Folded_position =[];\n                this.sets[id].genElements();\n                this.sets[id].setElements();\n                this.sets[id].genMeshes();\n            });\n        }\n    }\n    // toggleUnfoldState(id,toggle){\n    //     if(toggle){\n    //         this.updateSets(id, [id], (id) => {\n    //             this.sets[id].elements =[];\n    //             this.sets[id].meshes = [];\n    //             this.sets[id].genUnfoldPosition();\n    //             this.sets[id].genElements();\n    //             this.sets[id].setElements();\n    //             this.sets[id].genMeshes();\n    //         });\n    //     }\n    //     else if(toggle == false){\n    //         this.updateSets(id, [id], (id) => {\n    //             this.sets[id].elements =[];\n    //             this.sets[id].meshes = [];\n    //             this.sets[id].genFoldedPositionFromUnfold();\n    //             this.sets[id].genElements();\n    //             this.sets[id].setElements();\n    //             this.sets[id].genMeshes();\n    //         });\n    //     }\n    //}\n\n\n\n    /* REFERENCE TOOLS FUNCTIONS */\n\n\n    toggleGrid() {\n        this.gridEnabled = !this.gridEnabled;\n\n        if (this.gridEnabled) {\n            this.scene.add(this.tools.subGrid);\n        } else {\n            this.scene.remove(this.tools.subGrid);\n        }\n    }\n\n    toggleAxes() {\n        this.axesEnabled = !this.axesEnabled;\n\n        if (this.axesEnabled) {\n            for (let a of this.tools.axes) {\n                this.scene.add(a);\n            }\n        } else {\n            for (let a of this.tools.axes) {\n                this.scene.remove(a);\n            }\n        }\n\n\n    }\n\n    updateReferenceColour(rgb) {\n        let passGrid = false;\n        let passAxes = false;\n        let passShape = false;\n        if (this.gridEnabled) {\n            this.toggleGrid();\n            passGrid = true;\n        }\n        if (this.axesEnabled && !this.tools.multicolour) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n        if (this.boundingShapeEnabled) {\n            this.updateBoundingShape('', false);\n            passShape = true;\n        }\n        this.tools.updateColour(Model.rgbToHex(rgb.r, rgb.g, rgb.b));\n        if (passGrid) {\n            this.toggleGrid();\n        }\n        if (passAxes) {\n            this.toggleAxes();\n        }\n        if (passShape) {\n            this.updateBoundingShape(this.tools.boundingShapeType, true);\n            passShape = true;\n        }\n    }\n\n    toggleAxesMulticolour() {\n        let passAxes = false;\n        if (this.axesEnabled) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n        this.tools.toggleMulticolour();\n        if (passAxes) {\n            this.toggleAxes();\n        }\n    }\n\n    updateGridSize(size) {\n        let passGrid = false;\n        let passAxes = false;\n        if (this.gridEnabled) {\n            this.toggleGrid();\n            passGrid = true;\n        }\n        if (this.axesEnabled) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n\n        this.tools.updateSize(size);\n\n        if (passGrid) {\n            this.toggleGrid();\n        }\n        if (passAxes) {\n            this.toggleAxes();\n        }\n    }\n\n    updateBoundingShape(type, enabled) {\n        this.boundingShapeEnabled = enabled;\n        this.scene.remove(this.tools.boundingShape);\n        if (enabled) {\n            this.scene.add(this.tools.genBoundingShape(type, this.sets));\n        }\n    }\n\n    \n    \n\n    /* SLICING FUNCTIONS */\n\n    initClippers() {\n        this.clippingIntersections = false;\n       \n   \n        this.clippingPlanes = [\n            new Plane(new Vector3(1, 0, 0), 180),\n            new Plane(new Vector3(-1, 0, 0), 180),\n            new Plane(new Vector3(0, 1, 0), 180),\n            new Plane(new Vector3(0, -1, 0), 180),\n            new Plane(new Vector3(0, 0, 1), 180),\n            new Plane(new Vector3(0, 0, -1), 180)\n        ];\n       \n       this.clippingHelpers = [\n        new PlaneHelper(this.clippingPlanes[0], 100, 0xff0000),\n        new PlaneHelper(this.clippingPlanes[1], 100, 0xff0000),\n        new PlaneHelper(this.clippingPlanes[2], 100, 0x00ff00),\n        new PlaneHelper(this.clippingPlanes[3], 100, 0x00ff00),\n        new PlaneHelper(this.clippingPlanes[4], 100, 0x0000ff),\n        new PlaneHelper(this.clippingPlanes[5], 100, 0x0000ff)];\n\n        for (let helper of this.clippingHelpers) {\n            helper.visible = false;\n            this.scene.add(helper);\n        }\n\n        \n    }\n    removeclipping(){\n        for (let a of this.clippingPlanes) {\n            this.scene.remove(a);\n        }\n        for (let a of this.clippingHelpers) {\n            this.scene.remove(a);\n        }\n\n    \n    }\n    toggleClipIntersection(toggle) {\n        for (let set of this.sets) {\n            set.toggleClipIntersection(toggle);\n        }\n    }\n\n    toggleHelper(i, toggle) {\n        this.clippingHelpers[2 * i].visible = toggle;\n        this.clippingHelpers[2 * i + 1].visible = toggle;\n    }\n\n    updateSlicer(i, vals) {\n        for (let set of this.sets) {\n            set.updateSlicers(i, vals);\n        }\n    }\n\n\n    /* PERFORMANCE TEST SUITE */\n\n\n    initTesting(step) {\n        // set desirable testing view\n        this.setCamera('orthographic');\n        this.updateCameraZoom(8);\n        this.updateLightPosition(2, { x: 50, y: 0, z: 50 });\n\n        this.deleteAllMeshes();\n\n        this.testMaterial = new MeshLambertMaterial();\n        this.testShape = new SHAPE.Preset('Torus', Parameters.Torus.vals);\n        this.testShape.LOD = 2;\n        this.testShape.generate();\n        this.testTotal = 0;\n        this.testLimit = 3001;\n\n\n        this.notify('info', 'Initialising Performance Test',\n            (<p style={{ width: 320 }} >\n                Test Size: {this.testLimit.toString()} <br />\n            Step: {step.toString()} <br />\n            Shape: Torus (Default Parameters) <br />\n            Level of Detail: {(this.testShape.LOD + 1).toString()} <br />\n            Material: MeshPhongMaterial\n                <br/> <br/>\n            <b>Please do not change any settings while the performance test is running!</b>\n            </p>));\n\n        console.log('Material: MeshLambertMaterial')\n        console.log('Shape: Ellipsoid (Default Parameters)')\n        console.log('LOD: ' + (this.testShape.LOD + 1).toString())\n        console.log('Test Size: ' + this.testLimit.toString)\n        console.log('Test Step: ' + step.toString());\n    }\n\n    deleteAllMeshes() {\n        for (let i = this.scene.children.length - 1; i >= 0; i--) {\n            if (this.scene.children[i].type === \"Mesh\")\n                this.scene.remove(this.scene.children[i]);\n        }\n    }\n\n    addRandomParticles(n) {\n\n        this.testTotal += n;\n\n        if (this.testTotal >= this.testLimit) {\n            return true;\n        }\n\n        let geoms = [];\n        let m;\n        for (let i = 0; i < n; i++) {\n\n            if (this.testShape.isPreset) {\n                geoms.push(this.testShape.presetGeometry.clone());\n            }\n            else {\n                geoms.push(this.testShape.stripGeometry.clone());\n                geoms.push(this.testShape.fanGeometries[0].clone());\n                geoms.push(this.testShape.fanGeometries[1].clone());\n            }\n\n\n            this.translate([Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50], geoms);\n            for (let g of geoms) {\n                m = new Mesh(g, this.testMaterial);\n                this.scene.add(m);\n            }\n\n            geoms = [];\n        }\n\n\n        return false;\n    }\n\n    translate(pos, geoms) {\n        for (let g of geoms) {\n            g.translate(pos[0], pos[1], pos[2]);\n        }\n    }\n\n}\n\nexport default Model;\n","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/View.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/ReferenceTools.js",["74","75","76","77"],"import {\n    GridHelper,\n    LineBasicMaterial,\n    Vector3,\n    Color,\n    BufferGeometry,\n    Line,\n    Box3Helper,\n    Box3,\n    SphereBufferGeometry,\n    MeshBasicMaterial,\n    Mesh\n} from 'three';\nimport { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport {Alert} from 'rsuite';\n\nexport class ReferenceTools {\n    subGrid;\n    axes = [];\n    // boundingShape;\n    // boundingShapeType;\n    setsGeometry;\n    size;\n    colour;\n    material;\n    R;G;B;\n\n    constructor(s, c) {\n        this.size = s;\n        this.colour = c;\n\n        this.material = new LineBasicMaterial({\n            color: this.colour,\n            linewidth: 3\n        });\n\n        this.multicolour = true;\n        this.genMulticolourAxes();\n        this.genSubgrid();\n\n        this.R = new Color(\"rgb(255, 0, 0)\");\n        this.G = new Color(\"rgb(0, 255, 0)\");\n        this.B = new Color(\"rgb(0, 0, 255)\");\n\n        this.boundingShapeType = 'box';\n        this.setsGeometry = null;\n        \n    }\n\n    genBoundingShape(type, sets) {\n        this.boundingShapeType = type;\n        let b;\n        this.boundingShape = null;\n        \n        for (let set of sets) {\n            if (b != null){\n                break\n            }\n            b =set.genUnitBox()\n            \n        }\n    \n        switch (type) {\n            case 'box':\n                    let box = new Box3();\n                    box.setFromCenterAndSize(new Vector3(0,0,0),new Vector3(b[0]*2,b[1]*2,b[2]*2));\n                    this.boundingShape = new Box3Helper(box, this.colour);\n                    \n                break;\n            default:\n            Alert.error('Error: Unknown bounding shape identifier');\n            \n\n        }\n        \n\n        return this.boundingShape;\n\n    }\n\n   \n    updateColour(colour) {\n        this.colour = colour;\n        this.material = new LineBasicMaterial({\n            color: this.colour,\n            linewidth: 5\n        });\n        if(!this.multicolour){\n            this.genAxes();\n        }\n        this.genSubgrid();\n    }\n\n    updateSize(size) {\n        this.size = size;\n        if(this.multicolour){\n            this.genMulticolourAxes();\n        }else{\n            this.genAxes();\n        }\n        this.genSubgrid();\n    }\n\n    genSubgrid() {\n        this.subGrid = new GridHelper(this.size, this.size, this.colour, this.colour);\n    }\n\n    genAxes() {\n        this.axes = [];\n        let axesSize = this.size / 2;\n        this.axes.push(new Line(new BufferGeometry().setFromPoints([new Vector3(-axesSize, 0, 0), new Vector3(axesSize, 0, 0)]), this.material));\n        this.axes.push(new Line(new BufferGeometry().setFromPoints([new Vector3(0, -axesSize, 0), new Vector3(0, axesSize, 0)]), this.material));\n        this.axes.push(new Line(new BufferGeometry().setFromPoints([new Vector3(0, 0, -axesSize), new Vector3(0, 0, axesSize)]), this.material));\n    }\n\n    genMulticolourAxes(){\n        this.axes = [];\n        let axesSize = this.size / 2;\n        let mat1, mat2, mat3;\n        mat1 = new LineBasicMaterial({\n            color: this.R,\n            linewidth: 5\n        });\n        this.axes.push(new Line(new BufferGeometry().setFromPoints([new Vector3(-axesSize, 0, 0), new Vector3(axesSize, 0, 0)]), mat1));\n        mat2 = this.material = new LineBasicMaterial({\n            color: this.G,\n            linewidth: 5\n        });\n        this.axes.push(new Line(new BufferGeometry().setFromPoints([new Vector3(0, -axesSize, 0), new Vector3(0, axesSize, 0)]), mat2));\n        mat3 = this.material = new LineBasicMaterial({\n            color: this.B,\n            linewidth: 5\n        });\n        this.axes.push(new Line(new BufferGeometry().setFromPoints([new Vector3(0, 0, -axesSize), new Vector3(0, 0, axesSize)]), mat3));\n    }\n\n    toggleMulticolour(){\n        this.multicolour = !this.multicolour;\n        if(this.multicolour){\n            this.genMulticolourAxes();\n        }else{\n            this.updateColour(this.colour);\n            this.genAxes();\n        }\n    }\n   \n\n}\n\nexport default ReferenceTools;","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Set.js",["78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94"],"import {\n    Mesh,\n    MeshPhongMaterial,\n    Vector3,\n    Quaternion,\n    Euler,\n    Color,\n    Material\n\n} from 'three';\nimport * as THREE from 'three';\nimport {eigs, ParenthesisNodeDependencies, planckMassDependencies} from 'mathjs';\nimport * as SHAPE from './Shapes.js';\nimport Model from './Model';\nimport Parameters from './Parameters';\nimport { Alert } from 'rsuite';\nimport colourMap from './ColourMap.json';\n\nexport class Set {\n    name;\n    shapeType;\n    parameters;\n    shape;\n    orientationType;\n    wireframe;\n    userColour;\n    colourByDirector;\n    lod;\n    clippingPlanes;\n    clipIntersection;\n    colourMap;\n    unitBox;\n    \n    \n    \n    positions = [];\n    Folded_position=[]\n    orientations = [];\n    elements = [];\n    meshes = [];\n\n    \n\n    constructor(data, cp, ci) {\n        this.name = data.name;\n        this.orientationType = data.orientationType;\n        this.positions = data.positions;\n        this.orientations = data.orientations;\n        this.unitBox = data.unitBox;\n        this.clippingPlanes = cp;\n        this.clipIntersection = ci; \n\n        this.setDefaults();\n\n        if (data.shapeType != null) {\n            this.shapeType = data.shapeType;\n        }\n        if (data.parameters != null) {\n            this.shapeType = data.parameters;\n        }\n        if (this.name == null) {\n            this.name = this.shapeType;\n        }\n    \n        this.genSet();\n        \n    }\n\n    isFoldedTest(){\n        let x = this.unitBox[0]/2;\n        let y = this.unitBox[1]/2;\n        let z = this.unitBox[2]/2;\n        for (let i = 0; i < this.positions.length; i++){\n            let a = this.positions[i][0];\n            let b = this.positions[i][1];\n            let c = this.positions[i][2];\n            if(a>=x || a<=-x){\n                return false\n            }\n            if(b>=y|| b<=-y){\n                return false\n            }\n            if(c>=z || c<=-z){\n               return false\n            }\n        return true;\n        \n    }\n}\n\n    genSet(){\n        this.validateData();\n        this.genGeometries();\n        this.genElements();\n        this.setElements();\n        this.genMeshes();\n    }\n\n    \n\n    validateData() {\n        if (this.positions.length !== this.orientations.length) {\n            throw 'Error: Position data does not correspond to orientation data. \\n Total positions: ' + this.positions.length + '\\n Total rotations: ' + this.orientations.length;\n        }\n\n        for (let p in this.parameters) {\n            if (p < 0) {\n                throw 'Error: Invalid parameter ' + p.toString() + ' for ' + this.name + '\\n Must be positive.';\n            }\n        }\n\n        let defaultParameters = Set.getParameters(this.shapeType);\n        if (this.parameters.length != defaultParameters.vals.length) {\n            throw 'Error: Wrong number of parameters specified for ' + this.name + '. \\n Required: ' + defaultParameters.names;\n        }\n    }\n\n    setDefaults() {\n        this.userColour = new Color(\"#FFFFFF\");\n        this.colourByDirector = true;\n        this.wireframe = true;\n        // this.isFolded = this.isFoldedTest(); \n        this.lod = 2;\n        this.shapeType = 'Ellipsoid';\n        this.parameters = Parameters.Ellipsoid.vals;\n    }\n\n    updateSlicers(i, vals) {\n        this.clippingPlanes[2 * i + 1].constant = vals[1];\n        this.clippingPlanes[2 * i].constant = -vals[0];\n    }\n    // updateSlicedset(){\n    //     clippingPlanes = this.clippingPlanes;\n    //     for(let mesh of this.meshes){\n    //         mesh.material.geometries\n    //     }\n    // }\n    toggleClipIntersection(toggle) {\n        this.clipIntersection = toggle;\n        for (let mesh of this.meshes) {\n            mesh.material.clipIntersection = toggle;\n        }\n    }\n    genUnitBox(){\n    \n        return this.unitBox;\n\n    }\n\n    genUnfoldPosition(){\n    \n        if(this.isFoldedTest()== false){\n            Alert.info('Model is already unfolded');\n            return\n        }\n        let pos =[];\n        let x = this.unitBox[0];\n        let y = this.unitBox[1];\n        let z = this.unitBox[2];\n\n        for (let i = 0; i < this.positions.length; i++){\n            let rnd1 = (Math.random() * (2) -1) \n            let rnd2 = (Math.random() * (2) -1)\n            let rnd3 = (Math.random() * (2) -1)\n            pos.push([this.positions[i][0]+rnd1*x ,this.positions[i][1]+rnd2*y,this.positions[i][2]+rnd3*z])\n        }\n        this.positions = pos;\n        \n    }\n\n    genFoldedPositionFromUnfold(){\n        if(this.isFoldedTest()== true){\n            Alert.info('Model is already folded');\n            return\n        }\n        let pos =[];\n        let lx = this.unitBox[0]/2;\n        let ly = this.unitBox[1]/2;\n        let lz = this.unitBox[2]/2;\n\n        for (let i = 0; i < this.positions.length; i++){\n            let rx = this.positions[i][0];\n            let ry = this.positions[i][1];\n            let rz = this.positions[i][2];\n            \n            rx = rx%lx;\n            ry = ry%ly;\n            rz = rz%lz;\n           \n            pos.push([rx,ry,rz])\n        }\n        this.Folded_position = pos;\n        \n    }\n    inRange(target,min,max){\n        if (min<=target<=max ){\n            return true\n        }\n        else{\n            return false\n        }\n    }\n    genMeshes() {\n        let m;\n        let c;\n        let mat;\n        let gutsMaterial;\n        let v;\n        let ab =true;\n\n        for (let elem of this.elements) {\n            if (this.colourByDirector) {\n                let rgb = colourMap.values[elem.colourIndex];\n                c = new Color(Model.rgbToHex(...rgb));\n            } else {\n                c = this.userColour;\n            }\n        \n            mat = new MeshPhongMaterial({\n                color: c,\n                clippingPlanes: this.clippingPlanes,\n                clipIntersection: false,\n                side : THREE.FrontSide,\n                shininess: 40,\n                clipShadows: true\n            });\n            mat.wireframe = this.wireframe;\n            gutsMaterial = new THREE.MeshBasicMaterial( {color: c, side: THREE.BackSide, clippingPlanes: this.clippingPlanes, clipShadows: true} );\n        \n           \n            // mat = new MeshPhongMaterial({\n            //     color: c,\n            //     clippingPlanes: this.clippingPlanes,\n            //     clipIntersection: false,\n            //     side : THREE.FrontSide,\n            //     shininess: 40,\n            //     clipShadows: true\n            // });\n            // mat.wireframe = this.wireframe;\n            // gutsMaterial = new THREE.MeshBasicMaterial( {color: c, side: THREE.BackSide, clippingPlanes: this.clippingPlanes, clipShadows: true} );\n\t\t\t\t\t\n            //stencil buffer\n            //view-source:https://threejs.org/examples/webgl_clipping_stencil.html\n            //https://stackoverflow.com/questions/36557486/three-js-object-clipping/37593904#37593904\n\n            for (let g of elem.geometries) {\n                m = new Mesh(g, mat);\n                v = new Mesh(g,gutsMaterial)\n                this.meshes.push(m,v);\n            }\n        }\n    }\n\n    setElements() {\n        let geoms = [];\n\n        for (let elem of this.elements) {\n            if (this.shape.isPreset) {\n                geoms.push(this.shape.presetGeometry.clone());\n            }\n            else {\n                geoms.push(this.shape.stripGeometry.clone());\n                geoms.push(this.shape.fanGeometries[0].clone());\n                geoms.push(this.shape.fanGeometries[1].clone());\n            }\n\n            this.rotate(elem.euler, geoms);\n            this.translate(elem.position, geoms);\n            \n            elem.setGeometries(geoms);\n\n            geoms = [];\n        }\n    }\n\n    genElements() {\n        let pos = this.positions\n        if (this.Folded_position.length>0){\n            pos = this.Folded_position;\n        }\n        for (let i = 0; i < pos.length; i++) {\n            this.elements.push(new this.Element(pos[i], this.getRotations(this.orientationType, this.orientations[i])));\n        }\n        this.calculateDirector();\n        for(let elem of this.elements){\n            elem.setColourIndex(this.calculateColourIndex(elem));\n        }\n    }\n\n    genGeometries() {\n        switch (this.shapeType) {\n            case 'Ellipsoid':\n                this.shape = new SHAPE.Ellipsoid(...this.parameters);\n                break;\n            case 'Spherocylinder':\n                this.shape = new SHAPE.Spherocylinder(...this.parameters);\n                break;\n            case 'Spheroplatelet':\n                this.shape = new SHAPE.Spheroplatelet(...this.parameters);\n                break;\n            case 'Cut Sphere':\n                this.shape = new SHAPE.CutSphere(...this.parameters);\n                break;\n            case 'Sphere':\n                this.shape = new SHAPE.Preset('Sphere', this.parameters);\n                break;\n            case 'Cylinder':\n                this.shape = new SHAPE.Preset('Cylinder', this.parameters);\n                break;\n            case 'Torus':\n                this.shape = new SHAPE.Preset('Torus', this.parameters);\n                break;\n            default:\n                throw 'Error: unexpected shape identifier. \\n Found: ' + this.shapeType;\n        }\n\n        this.shape.LOD = this.lod;\n        this.shape.generate();\n    }\n\n    translate(pos, geoms) {\n        for (let g of geoms) {\n            g.translate(2*pos[0], 2*pos[1], 2*pos[2]);\n        }\n    }\n\n    rotate(e, geoms) {\n        for (let g of geoms) {\n            g.rotateZ(e.z);\n            g.rotateY(e.y);\n            g.rotateX(e.x);\n            \n            \n        }\n    }\n\n    getRotations(type, rot) {\n        let q = new Quaternion();\n        switch (type) {\n            case 'v':\n                let orientationVector = new Vector3(rot[0], rot[1], rot[2])\n                orientationVector.normalize();\n                q.setFromUnitVectors(new Vector3(0, 0, 1), orientationVector);\n                break;\n            case 'q':\n                q.set(rot[1], rot[2], rot[3], rot[0]);\n                break;\n            case 'a':\n                q.setFromAxisAngle(new Vector3(rot[0], rot[1], rot[2]), rot[3]);\n                break;\n            case 'e':\n                let e = new Euler();\n                e.fromArray(rot);\n                q.setFromEuler(e)\n                break;\n            default:\n                throw 'Error: Unexpected rotation type value. \\n Found: ' + type + '\\n Expected: v | q | a | e';\n        }\n\n        q.normalize();\n\n        return q;\n\n    }\n\n    colourFromOrientation(euler) {\n        let colour = [];\n\n        colour.push(Math.round((euler._x + Math.PI) / (2 * Math.PI) * (255)));\n        colour.push(Math.round((euler._y + Math.PI) / (2 * Math.PI) * (255)));\n        colour.push(Math.round((euler._z + Math.PI) / (2 * Math.PI) * (255)));\n\n        return colour;\n    }\n\n    calculateDirector() {\n        let n = this.elements.length;\n\n        if (this.elements.length == 0) {\n            Alert.error('Error: No elements in set, director calculation failed.');\n            return;\n        }\n\n        let orderTensor = [[0,0,0],[0,0,0],[0,0,0]];\n        //let eigenvectorsInColumns = new Matrix3();\n\n        let factor = 3 / (2 * n);\n        let constant = 0.5;\n\n        let orientation;\n\n        // loop over all molecules and calculate order tensor\n        for (let i = 0; i < n; ++i) {\n            orientation = this.elements[i].orientation;\n            orderTensor[0][0] += orientation[0]**2;\n            orderTensor[0][1] += orientation[0]*orientation[1];\n            orderTensor[0][2] += orientation[0]*orientation[2];\n            orderTensor[1][1] += orientation[1]**2;\n            orderTensor[1][2] += orientation[1]*orientation[2];\n            orderTensor[2][2] += orientation[2]**2;\n        }\n\n        // multiply each tensor value with \"factor\" and afterwards subtract \"subtract\" from diagonal elements\n        orderTensor[0][0] *= factor; orderTensor[0][0] -= constant;\n        orderTensor[0][1] *= factor;\n        orderTensor[0][2] *= factor;\n        orderTensor[1][1] *= factor; orderTensor[1][1] -= constant;\n        orderTensor[1][2] *= factor;\n        orderTensor[2][2] *= factor; orderTensor[2][2] -= constant;\n\n        // mirror matrix to make it symmetric\n        orderTensor[1][0] = orderTensor[0][1];\n        orderTensor[2][0] = orderTensor[0][2];\n        orderTensor[2][1] = orderTensor[1][2];\n\n        let eigen = eigs(orderTensor);\n        \n        //returns index of max eigenvalue\n        //this line of code is a bit dodgy\n        let index = eigen.values.reduce((iMax, x, i, arr) => x > arr[iMax] ? i : iMax, 0);\n\n        this.director = eigen.vectors[index];\n\n        let norm = Math.sqrt(this.director[0]**2 + this.director[1]**2 + this.director[2]**2);\n\n        if (norm == 0 || norm == NaN || norm == undefined){\n            this.director = [0,0,1];\n        }else{\n            this.director[0] /= norm;\n            this.director[1] /= norm;\n            this.director[2] /= norm;\n        }\n\n        // TEST!\n    }\n\n    calculateColourIndex(element){\n        let n = colourMap.values.length - 1;\n\n        let scalarProduct = Math.abs(element.orientation[0] * this.director[0]\n            + element.orientation[1] * this.director[1]\n            + element.orientation[2] * this.director[2]);\n\n        if (scalarProduct > 1){scalarProduct = 1;}\n\n        return Math.round(Math.acos( scalarProduct )/Math.PI*2*( n ));;\n    }\n\n    setUserColour(hex) {\n        this.userColour = new Color(hex);\n    }\n\n    static getParameters(val) {\n        let parameters;\n\n        switch (val) {\n            case 'Ellipsoid':\n                parameters = Parameters.Ellipsoid;\n                break;\n            case 'Spherocylinder':\n                parameters = Parameters.Spherocylinder;\n                break;\n            case 'Spheroplatelet':\n                parameters = Parameters.Spheroplatelet;\n                break;\n            case 'Cut Sphere':\n                parameters = Parameters.CutSphere;\n                break;\n            case 'Sphere':\n                parameters = Parameters.Sphere;\n                break;\n            case 'Cylinder':\n                parameters = Parameters.Cylinder;\n                break;\n            case 'Torus':\n                parameters = Parameters.Torus;\n                break;\n            default:\n                Alert.error('Error: Unexpected shape identifier');\n        }\n\n        return parameters;\n    }\n\n    Element = class Element {\n        geometries;\n        orientation;\n        position;\n        colourIndex;\n        euler;\n\n        constructor(p, q) {\n            this.position = p;\n            this.orientation = this.quaternionToUnitVector(q);\n\n            this.euler = new Euler();\n            this.euler.setFromQuaternion(q);\n            this.colourIndex = 0;\n        }\n\n        quaternionToUnitVector(q){\n            let a = (2 * (   q.w*q.y + q.x*q.z ));\n            let b = (2 * ( - q.w*q.x + q.y*q.z ));\n            let c = (1 - 2 * ( q.x**2 + q.y**2 ));\n            return [a,b,c];\n        }\n\n        setColourIndex(i){\n            this.colourIndex = i;\n        }\n\n        getColour() {\n            return Model.rgbToHex(this.colour[0], this.colour[1], this.colour[2]);\n        }\n\n        setGeometries(geoms) {\n            this.geometries = geoms;\n        }\n\n    }\n}\n\nexport default Set;","/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Light.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Shapes.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/Model/Parameters.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/VisualisationMenu.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/GeneralMenu.js",["95","96"],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/Tools.js",[],"/Users/yuiisyue/Documents/GitHub/WebMGA-main/src/View/SubMenus.js",["97","98","99","100","101","102","103","104","105","106"],{"ruleId":"107","replacedBy":"108"},{"ruleId":"109","replacedBy":"110"},{"ruleId":"111","severity":1,"message":"112","line":89,"column":30,"nodeType":"113","messageId":"114","endLine":89,"endColumn":32},{"ruleId":"111","severity":1,"message":"112","line":410,"column":21,"nodeType":"113","messageId":"114","endLine":410,"endColumn":23},{"ruleId":"111","severity":1,"message":"112","line":418,"column":21,"nodeType":"113","messageId":"114","endLine":418,"endColumn":23},{"ruleId":"115","severity":1,"message":"116","line":10,"column":5,"nodeType":"117","messageId":"118","endLine":10,"endColumn":22},{"ruleId":"115","severity":1,"message":"119","line":11,"column":5,"nodeType":"117","messageId":"118","endLine":11,"endColumn":25},{"ruleId":"111","severity":1,"message":"112","line":153,"column":29,"nodeType":"113","messageId":"114","endLine":153,"endColumn":31},{"ruleId":"111","severity":1,"message":"120","line":329,"column":18,"nodeType":"113","messageId":"114","endLine":329,"endColumn":20},{"ruleId":"111","severity":1,"message":"112","line":336,"column":31,"nodeType":"113","messageId":"114","endLine":336,"endColumn":33},{"ruleId":"111","severity":1,"message":"112","line":354,"column":18,"nodeType":"113","messageId":"114","endLine":354,"endColumn":20},{"ruleId":"111","severity":1,"message":"112","line":363,"column":24,"nodeType":"113","messageId":"114","endLine":363,"endColumn":26},{"ruleId":"115","severity":1,"message":"121","line":10,"column":5,"nodeType":"117","messageId":"118","endLine":10,"endColumn":25},{"ruleId":"115","severity":1,"message":"122","line":11,"column":5,"nodeType":"117","messageId":"118","endLine":11,"endColumn":22},{"ruleId":"115","severity":1,"message":"123","line":12,"column":5,"nodeType":"117","messageId":"118","endLine":12,"endColumn":9},{"ruleId":"115","severity":1,"message":"124","line":14,"column":10,"nodeType":"117","messageId":"118","endLine":14,"endColumn":29},{"ruleId":"115","severity":1,"message":"125","line":8,"column":5,"nodeType":"117","messageId":"118","endLine":8,"endColumn":13},{"ruleId":"115","severity":1,"message":"126","line":12,"column":15,"nodeType":"117","messageId":"118","endLine":12,"endColumn":42},{"ruleId":"115","severity":1,"message":"127","line":12,"column":44,"nodeType":"117","messageId":"118","endLine":12,"endColumn":66},{"ruleId":"128","severity":1,"message":"129","line":103,"column":13,"nodeType":"130","messageId":"131","endLine":103,"endColumn":180},{"ruleId":"128","severity":1,"message":"129","line":108,"column":17,"nodeType":"130","messageId":"131","endLine":108,"endColumn":113},{"ruleId":"111","severity":1,"message":"120","line":113,"column":36,"nodeType":"113","messageId":"114","endLine":113,"endColumn":38},{"ruleId":"128","severity":1,"message":"129","line":114,"column":13,"nodeType":"130","messageId":"131","endLine":114,"endColumn":128},{"ruleId":"111","severity":1,"message":"112","line":152,"column":31,"nodeType":"113","messageId":"114","endLine":152,"endColumn":33},{"ruleId":"111","severity":1,"message":"112","line":172,"column":31,"nodeType":"113","messageId":"114","endLine":172,"endColumn":33},{"ruleId":"115","severity":1,"message":"132","line":209,"column":13,"nodeType":"117","messageId":"118","endLine":209,"endColumn":15},{"ruleId":"128","severity":1,"message":"129","line":314,"column":17,"nodeType":"130","messageId":"131","endLine":314,"endColumn":89},{"ruleId":"128","severity":1,"message":"129","line":357,"column":17,"nodeType":"130","messageId":"131","endLine":357,"endColumn":113},{"ruleId":"111","severity":1,"message":"112","line":379,"column":34,"nodeType":"113","messageId":"114","endLine":379,"endColumn":36},{"ruleId":"111","severity":1,"message":"112","line":426,"column":18,"nodeType":"113","messageId":"114","endLine":426,"endColumn":20},{"ruleId":"133","severity":1,"message":"134","line":426,"column":26,"nodeType":"113","messageId":"135","endLine":426,"endColumn":37},{"ruleId":"111","severity":1,"message":"112","line":426,"column":31,"nodeType":"113","messageId":"114","endLine":426,"endColumn":33},{"ruleId":"111","severity":1,"message":"112","line":426,"column":46,"nodeType":"113","messageId":"114","endLine":426,"endColumn":48},{"ruleId":"115","severity":1,"message":"136","line":2,"column":135,"nodeType":"117","messageId":"118","endLine":2,"endColumn":142},{"ruleId":"115","severity":1,"message":"137","line":67,"column":15,"nodeType":"117","messageId":"118","endLine":67,"endColumn":20},{"ruleId":"111","severity":1,"message":"112","line":234,"column":18,"nodeType":"113","messageId":"114","endLine":234,"endColumn":20},{"ruleId":"138","severity":1,"message":"139","line":255,"column":9,"nodeType":"140","messageId":"141","endLine":255,"endColumn":19},{"ruleId":"111","severity":1,"message":"112","line":354,"column":17,"nodeType":"113","messageId":"114","endLine":354,"endColumn":19},{"ruleId":"133","severity":1,"message":"134","line":366,"column":13,"nodeType":"113","messageId":"135","endLine":366,"endColumn":23},{"ruleId":"111","severity":1,"message":"120","line":366,"column":17,"nodeType":"113","messageId":"114","endLine":366,"endColumn":19},{"ruleId":"133","severity":1,"message":"134","line":391,"column":13,"nodeType":"113","messageId":"135","endLine":391,"endColumn":23},{"ruleId":"111","severity":1,"message":"120","line":391,"column":17,"nodeType":"113","messageId":"114","endLine":391,"endColumn":19},{"ruleId":"138","severity":1,"message":"139","line":546,"column":17,"nodeType":"140","messageId":"141","endLine":546,"endColumn":27},{"ruleId":"138","severity":1,"message":"139","line":549,"column":17,"nodeType":"140","messageId":"141","endLine":549,"endColumn":27},{"ruleId":"138","severity":1,"message":"139","line":552,"column":17,"nodeType":"140","messageId":"141","endLine":552,"endColumn":27},"no-native-reassign",["142"],"no-negated-in-lhs",["143"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'MeshPhongMaterial' is defined but never used.","Identifier","unusedVar","'MeshStandardMaterial' is defined but never used.","Expected '!==' and instead saw '!='.","'SphereBufferGeometry' is defined but never used.","'MeshBasicMaterial' is defined but never used.","'Mesh' is defined but never used.","'BufferGeometryUtils' is defined but never used.","'Material' is defined but never used.","'ParenthesisNodeDependencies' is defined but never used.","'planckMassDependencies' is defined but never used.","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","'ab' is assigned a value but never used.","use-isnan","Use the isNaN function to compare with NaN.","comparisonWithNaN","'Divider' is defined but never used.","'state' is assigned a value but never used.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","noDirectMutation","no-global-assign","no-unsafe-negation"]